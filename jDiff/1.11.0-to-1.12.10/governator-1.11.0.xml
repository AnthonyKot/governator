<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Tue Apr 05 13:28:34 PDT 2016 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="governator-1.11.0"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/nyap/proj/bootstrap-governator-gh-pages/governator/buildSrc/lib/jdiff-1.1.1/jdiff.jar:/home/nyap/proj/bootstrap-governator-gh-pages/governator/buildSrc/lib/jdiff-1.1.1/xerces.jar -d /home/nyap/proj/bootstrap-governator-gh-pages/governator/build/reports/jDiff/1.11.0-to-1.12.10 -classpath /home/nyap/proj/bootstrap-governator-gh-pages/.gradle/wrapper/dists/gradle-2.2.1-all/c64ydeuardnfqctvr1gm30w53/gradle-2.2.1/lib/gradle-launcher-2.2.1.jar -sourcepath /home/nyap/proj/bootstrap-governator-gh-pages/governator/build/jDiff/governator-1.11.0/governator-commons-cli/src/main/java:/home/nyap/proj/bootstrap-governator-gh-pages/governator/build/jDiff/governator-1.11.0/governator-legacy/src/main/java:/home/nyap/proj/bootstrap-governator-gh-pages/governator/build/jDiff/governator-1.11.0/governator-servlet/src/main/java:/home/nyap/proj/bootstrap-governator-gh-pages/governator/build/jDiff/governator-1.11.0/governator-jetty/src/main/java:/home/nyap/proj/bootstrap-governator-gh-pages/governator/build/jDiff/governator-1.11.0/governator-test-junit/src/main/java:/home/nyap/proj/bootstrap-governator-gh-pages/governator/build/jDiff/governator-1.11.0/governator-archaius/src/main/java:/home/nyap/proj/bootstrap-governator-gh-pages/governator/build/jDiff/governator-1.11.0/governator-api/src/main/java:/home/nyap/proj/bootstrap-governator-gh-pages/governator/build/jDiff/governator-1.11.0/governator-core/src/main/java -doclet jdiff.JDiff -docletpath /home/nyap/proj/bootstrap-governator-gh-pages/governator/buildSrc/lib/jdiff-1.1.1/jdiff.jar:/home/nyap/proj/bootstrap-governator-gh-pages/governator/buildSrc/lib/jdiff-1.1.1/xerces.jar -apiname governator-1.11.0 -baseURI http://www.w3.org -apidir /home/nyap/proj/bootstrap-governator-gh-pages/governator/build/reports/jDiff/1.11.0-to-1.12.10 -source 1.8 -->
<package name="com.netflix.governator">
  <!-- start class com.netflix.governator.AbstractLifecycleListener -->
  <class name="AbstractLifecycleListener" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.spi.LifecycleListener"/>
    <constructor name="AbstractLifecycleListener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="onStopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="onStarted"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.netflix.governator.AbstractLifecycleListener -->
  <!-- start class com.netflix.governator.AbstractLifecycleShutdownSignal -->
  <class name="AbstractLifecycleShutdownSignal" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.LifecycleShutdownSignal"/>
    <constructor name="AbstractLifecycleShutdownSignal" type="com.netflix.governator.LifecycleManager"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.netflix.governator.AbstractLifecycleShutdownSignal -->
  <!-- start class com.netflix.governator.AbstractPropertySource -->
  <class name="AbstractPropertySource" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.spi.PropertySource"/>
    <constructor name="AbstractPropertySource"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="defaultValue" type="T"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.AbstractPropertySource -->
  <!-- start class com.netflix.governator.BindingLoggingModuleTransformer -->
  <class name="BindingLoggingModuleTransformer" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.spi.ModuleListTransformer"/>
    <constructor name="BindingLoggingModuleTransformer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="transform" return="java.util.List&lt;Module&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.List&lt;Module&gt;"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.BindingLoggingModuleTransformer -->
  <!-- start class com.netflix.governator.ConfigurationLifecycleFeature -->
  <class name="ConfigurationLifecycleFeature" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.LifecycleFeature"/>
    <constructor name="ConfigurationLifecycleFeature"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="initialize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mapper" type="com.netflix.governator.configuration.ConfigurationMapper"/>
      <param name="configurationProvider" type="com.netflix.governator.configuration.ConfigurationProvider"/>
      <param name="configurationDocumentation" type="com.netflix.governator.configuration.ConfigurationDocumentation"/>
    </method>
    <method name="getActionsForType" return="java.util.List&lt;com.netflix.governator.LifecycleAction&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Feature to enable @Configuration annotation processing.
 
 To enable install the ConfigurationModule.
 
 <pre>
 {@code
 install(new ConfigurationModule());
 }
 </pre>
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.ConfigurationLifecycleFeature -->
  <!-- start class com.netflix.governator.ConfigurationModule -->
  <class name="ConfigurationModule" extends="AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigurationModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Install this module to enable @Configuration and @ConfigurationParameter 
 annotation processing.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.ConfigurationModule -->
  <!-- start class com.netflix.governator.DefaultLifecycleShutdownSignal -->
  <class name="DefaultLifecycleShutdownSignal" extends="com.netflix.governator.AbstractLifecycleShutdownSignal"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DefaultLifecycleShutdownSignal" type="com.netflix.governator.LifecycleManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="signal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="await"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <doc>
    <![CDATA[Default shutdown signal, mostly to be used for runtime applications, using
 a CountDown latch.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.DefaultLifecycleShutdownSignal -->
  <!-- start class com.netflix.governator.DelegatingInjector -->
  <class name="DelegatingInjector" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DelegatingInjector" type="Injector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="injectMembers"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
    </method>
    <method name="getMembersInjector" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="&lt;any&gt;"/>
    </method>
    <method name="getMembersInjector" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="getBindings" return="java.util.Map&lt;&lt;any&gt;, &lt;any&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAllBindings" return="java.util.Map&lt;&lt;any&gt;, &lt;any&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getBinding" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="&lt;any&gt;"/>
    </method>
    <method name="getBinding" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="getExistingBinding" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="&lt;any&gt;"/>
    </method>
    <method name="findBindingsByType" return="java.util.List&lt;&lt;any&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
    </method>
    <method name="getProvider" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="&lt;any&gt;"/>
    </method>
    <method name="getProvider" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="&lt;any&gt;"/>
    </method>
    <method name="getParent" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createChildInjector" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends Module&gt;"/>
    </method>
    <method name="createChildInjector" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
    </method>
    <method name="getScopeBindings" return="java.util.Map&lt;java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;, Scope&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypeConverterBindings" return="java.util.Set&lt;TypeConverterBinding&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.netflix.governator.DelegatingInjector -->
  <!-- start class com.netflix.governator.Governator -->
  <class name="Governator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="2015-12-13 Use {@link InjectorBuilder} instead">
    <constructor name="Governator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addModules" return="com.netflix.governator.Governator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
      <doc>
      <![CDATA[Add Guice modules to Governator.  
 
 @param modules Guice modules to add.  
 @return this]]>
      </doc>
    </method>
    <method name="addModules" return="com.netflix.governator.Governator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.List&lt;Module&gt;"/>
      <doc>
      <![CDATA[Add Guice modules to Governator.  
 
 @param modules Guice modules to add.  
 @return this]]>
      </doc>
    </method>
    <method name="addProfile" return="com.netflix.governator.Governator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profile" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a runtime profile.  Profiles are processed by the conditional binding {@literal @}ConditionalOnProfile and
 are injectable as {@literal @}Profiles Set{@literal <}String{@literal >}.
 
 @param profile A profile
 @return this]]>
      </doc>
    </method>
    <method name="addProfiles" return="com.netflix.governator.Governator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profiles" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Add a runtime profiles.  Profiles are processed by the conditional binding {@literal @}ConditionalOnProfile and
 are injectable as {@literal @}Profiles Set{@literal <}String{@literal >}.
 
 @param profiles Set of profiles
 @return this]]>
      </doc>
    </method>
    <method name="addProfiles" return="com.netflix.governator.Governator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profiles" type="java.util.Collection&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[Add a runtime profiles.  Profiles are processed by the conditional binding {@literal @}ConditionalOnProfile and
 are injectable as {@literal @}Profiles Set{@literal <}String{@literal >}.
 
 @param profiles Set of profiles
 @return this]]>
      </doc>
    </method>
    <method name="enableFeature" return="com.netflix.governator.Governator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="feature" type="com.netflix.governator.GovernatorFeature&lt;java.lang.Boolean&gt;"/>
      <doc>
      <![CDATA[Enable the specified feature
 @param feature Boolean feature to enable
 @return this]]>
      </doc>
    </method>
    <method name="enableFeature" return="com.netflix.governator.Governator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="feature" type="com.netflix.governator.GovernatorFeature&lt;java.lang.Boolean&gt;"/>
      <param name="enabled" type="boolean"/>
      <doc>
      <![CDATA[Enable or disable the specified feature
 @param feature Boolean feature to disable
 @return this]]>
      </doc>
    </method>
    <method name="disableFeature" return="com.netflix.governator.Governator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="feature" type="com.netflix.governator.GovernatorFeature&lt;java.lang.Boolean&gt;"/>
      <doc>
      <![CDATA[Disable the specified feature
 @param feature Boolean feature to enable/disable
 @return this]]>
      </doc>
    </method>
    <method name="setFeature" return="com.netflix.governator.Governator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="feature" type="com.netflix.governator.GovernatorFeature&lt;T&gt;"/>
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Set a feature
 @param feature Feature to set
 @return this]]>
      </doc>
    </method>
    <method name="addModuleListTransformer" return="com.netflix.governator.Governator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transformer" type="com.netflix.governator.spi.ModuleListTransformer"/>
      <doc>
      <![CDATA[Add a ModuleListTransformer that will be invoked on the final list of modules
 prior to creating the injectors.  Multiple transformers may be added with each
 transforming the result of the previous one.
 
 @param transformer A transformer
 @return this]]>
      </doc>
    </method>
    <method name="addOverrideModules" return="com.netflix.governator.Governator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
      <doc>
      <![CDATA[Add override modules for any modules add via addModules or that are 
 conditionally loaded.  This is useful for testing or when an application
 absolutely needs to override a binding to fix a binding problem in the
 code modules
 @param modules Modules that will be applied as overrides to modules
 @return this]]>
      </doc>
    </method>
    <method name="addOverrideModules" return="com.netflix.governator.Governator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.List&lt;Module&gt;"/>
      <doc>
      <![CDATA[Add override modules for any modules add via addModules or that are 
 conditionally loaded.  This is useful for testing or when an application
 absolutely needs to override a binding to fix a binding problem in the
 code modules
 @param modules Modules that will be applied as overrides to modules
 @return this]]>
      </doc>
    </method>
    <method name="createInjector" return="com.netflix.governator.LifecycleInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Call new Governator().addModules(modules).run() instead.">
      <param name="modules" type="Module[]"/>
      <doc>
      <![CDATA[@deprecated Call new Governator().addModules(modules).run() instead.]]>
      </doc>
    </method>
    <method name="createInjector" return="com.netflix.governator.LifecycleInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Call new Governator().addModules(modules).run() instead.">
      <param name="modules" type="java.util.Collection&lt;Module&gt;"/>
      <doc>
      <![CDATA[@deprecated Call new Governator().addModules(modules).run() instead.]]>
      </doc>
    </method>
    <method name="run" return="com.netflix.governator.LifecycleInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create the injector and call any LifecycleListeners
 @return the LifecycleInjector for this run]]>
      </doc>
    </method>
    <method name="run" return="com.netflix.governator.LifecycleInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="run" return="com.netflix.governator.LifecycleInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mainClass" type="java.lang.Class&lt;? extends com.netflix.governator.spi.LifecycleListener&gt;"/>
    </method>
    <method name="run" return="com.netflix.governator.LifecycleInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mainClass" type="com.netflix.governator.spi.LifecycleListener"/>
    </method>
    <method name="run" return="com.netflix.governator.LifecycleInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mainClass" type="com.netflix.governator.spi.LifecycleListener"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="run" return="com.netflix.governator.LifecycleInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mainClass" type="java.lang.Class&lt;? extends com.netflix.governator.spi.LifecycleListener&gt;"/>
      <param name="args" type="java.lang.String[]"/>
    </method>
    <field name="profiles" type="java.util.Set&lt;java.lang.String&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="modules" type="java.util.List&lt;Module&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="transformers" type="java.util.List&lt;com.netflix.governator.spi.ModuleListTransformer&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="overrideModules" type="java.util.List&lt;Module&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <field name="featureOverrides" type="java.util.IdentityHashMap&lt;com.netflix.governator.GovernatorFeature&lt;?&gt;, java.lang.Object&gt;"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Main entry point for creating a LifecycleInjector with guice extensions such as 
 support for @PostConstruct, @PreDestroy annotations and LifecycleListener.
 
 Example:
 <code>
     new Governator()
        .addModules(
            new ArchaiusGovernatorModule(),
            new JettyModule(),
            new JerseyServletModule() {
                {@literal @}@Override
                protected void configureServlets() {
                    serve("/*").with(GuiceContainer.class);
                    
                    bind(GuiceContainer.class).asEagerSingleton();
                    bind(HelloWorldApp.class).asEagerSingleton();
                }  
            }
        )
        .run()
        .awaitTermination();
 </code>
 
 @deprecated 2015-12-13 Use {@link InjectorBuilder} instead]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.Governator -->
  <!-- start class com.netflix.governator.GovernatorFeature -->
  <class name="GovernatorFeature" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GovernatorFeature" type="java.lang.String, T"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="create" return="com.netflix.governator.GovernatorFeature&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="defaultValue" type="T"/>
    </method>
    <method name="getKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getType" return="java.lang.Class&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDefaultValue" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.netflix.governator.GovernatorFeature -->
  <!-- start class com.netflix.governator.GovernatorFeatures -->
  <class name="GovernatorFeatures" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="GovernatorFeatures"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="SHUTDOWN_ON_ERROR" type="com.netflix.governator.GovernatorFeature&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When disable the Governator process will continue running even if there is a catastrophic 
 startup failure.  This allows the admin page to stay up so that the process may be 
 debugged more easily.]]>
      </doc>
    </field>
    <field name="DISCOVER_AUTO_BINDERS" type="com.netflix.governator.GovernatorFeature&lt;java.lang.Boolean&gt;"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Auto discover AutoBinders using the ServiceLoader]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Core Governator features.  Features are configured/enabled on {@link Governator}]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.GovernatorFeatures -->
  <!-- start class com.netflix.governator.InjectorBuilder -->
  <class name="InjectorBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="fromModule" return="com.netflix.governator.InjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="Module"/>
      <doc>
      <![CDATA[Start the builder using the specified module. 
 
 @param module
 @return]]>
      </doc>
    </method>
    <method name="fromModules" return="com.netflix.governator.InjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="firstModule" type="Module"/>
      <param name="secondModule" type="Module"/>
      <param name="additionalModules" type="Module[]"/>
    </method>
    <method name="fromModules" return="com.netflix.governator.InjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.List&lt;Module&gt;"/>
    </method>
    <method name="overrideWith" return="com.netflix.governator.InjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
      <doc>
      <![CDATA[Override all existing bindings with bindings in the provided modules.
 This method uses Guice's build in {@link Modules#override} and is preferable
 to using {@link Modules#override}.  The approach here is to attempt to promote 
 the use of {@link Modules#override} as a single top level override.  Using
 {@link Modules#override} inside Guice modules can result in duplicate bindings 
 when the same module is installed in multiple placed. 
 @param modules]]>
      </doc>
    </method>
    <method name="overrideWith" return="com.netflix.governator.InjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.Collection&lt;Module&gt;"/>
      <doc>
      <![CDATA[@see InjectorBuilder#overrideWith(Module...)]]>
      </doc>
    </method>
    <method name="combineWith" return="com.netflix.governator.InjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
      <doc>
      <![CDATA[Add additional bindings to the module tracked by the DSL
 @param modules]]>
      </doc>
    </method>
    <method name="traceEachElement" return="com.netflix.governator.InjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[Iterator through all elements of the current module and write the output of the
 ElementVisitor to the logger at debug level.  'null' responses are ignored
 @param visitor]]>
      </doc>
    </method>
    <method name="traceEachKey" return="com.netflix.governator.InjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Log the current binding state.  traceEachKey() is useful for debugging a sequence of
 operation where the binding snapshot can be dumped to the log after an operation.]]>
      </doc>
    </method>
    <method name="warnOfStaticInjections" return="com.netflix.governator.InjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Log a warning that static injection is being used.  Static injection is considered a 'hack'
 to alllow for backwards compatibility with non DI'd static code.]]>
      </doc>
    </method>
    <method name="map" return="com.netflix.governator.InjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transformer" type="com.netflix.governator.spi.ModuleTransformer"/>
      <doc>
      <![CDATA[Extend the core DSL by providing a custom ModuleTransformer.  The output module 
 replaces the current module.
 @param transformer]]>
      </doc>
    </method>
    <method name="filter" return="com.netflix.governator.InjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="predicate" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[Filter out elements for which the provided visitor returns true.
 @param predicate]]>
      </doc>
    </method>
    <method name="stripStaticInjections" return="com.netflix.governator.InjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Filter out all bindings using requestStaticInjection]]>
      </doc>
    </method>
    <method name="getElements" return="java.util.List&lt;Element&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return Return all elements in the managed module]]>
      </doc>
    </method>
    <method name="createInjector" return="I extends Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="Stage"/>
      <param name="creator" type="com.netflix.governator.spi.InjectorCreator&lt;I&gt;"/>
      <doc>
      <![CDATA[Create the injector in the specified stage using the specified InjectorCreator
 strategy.  The InjectorCreator will most likely perform additional error handling on top 
 of the call to {@link Guice#createInjector}.
 
 @param stage     Stage in which the injector is running.  It is recommended to run in Stage.DEVELOPEMENT
                  since it treats all singletons as lazy as opposed to defaulting to eager instantiation which 
                  could result in instantiating unwanted classes.
 @param creator]]>
      </doc>
    </method>
    <method name="createInjector" return="I extends Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="creator" type="com.netflix.governator.spi.InjectorCreator&lt;I&gt;"/>
      <doc>
      <![CDATA[@see {@link InjectorBuilder#createInjector(Stage, InjectorCreator)}]]>
      </doc>
    </method>
    <method name="createInjector" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="Stage"/>
      <doc>
      <![CDATA[@see {@link InjectorBuilder#createInjector(Stage, InjectorCreator)}]]>
      </doc>
    </method>
    <method name="createInjector" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see {@link InjectorBuilder#createInjector(Stage, InjectorCreator)}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simple DSL on top of Guice through which an injector may be created using a series
 of operations and transformations of Guice modules.  Operations are tracked using a 
 single module and are additive such that each operation executes on top of the entire 
 current binding state.  Once all bindings have been defined the injector can be created 
 using an {@link InjectorCreator} strategy.
 
 <code>
 InjectorBuilder
      .fromModule(new MyApplicationModule())
      .overrideWith(new OverridesForTesting())
      .traceEachElement(new BindingTracingVisitor())
      .createInjector();
 </code>]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.InjectorBuilder -->
  <!-- start class com.netflix.governator.LegacyScopesModule -->
  <class name="LegacyScopesModule" extends="AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LegacyScopesModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.netflix.governator.LegacyScopesModule -->
  <!-- start interface com.netflix.governator.LifecycleAction -->
  <interface name="LifecycleAction"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Invoke the action on an object.
 
 @param obj
 @throws Exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Generic interface for actions to be invoked as part of lifecycle 
 management.  This includes actions such as PostConstruct, PreDestroy
 and configuration related mapping.
 
 @see LifecycleFeature
 
 @author elandau]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.LifecycleAction -->
  <!-- start interface com.netflix.governator.LifecycleFeature -->
  <interface name="LifecycleFeature"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getActionsForType" return="java.util.List&lt;com.netflix.governator.LifecycleAction&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Return a list of actions to perform on object of this type as part of 
 lifecycle processing.  Each LifecycleAction will likely be tied to processing 
 of a specific field or method.
 
 @param type
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Each LifecycleFeature provides support for specific post constructor 
 pre-@PostConstruct processing of an injected object.  For example,
 {@link ConfigurationLifecycleFeature} enables configuration mapping
 prior to @PostConstruct being called.
 
 {@link LifecycleFeature}s are added via a multibinding. For example,
 
 <pre>
 {@code
 Multibinder.newSetBinder(binder(), LifecycleFeature.class).addBinding().to(ConfigurationLifecycleFeature.class);
 }
 </pre>
 
 @author elandau]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.LifecycleFeature -->
  <!-- start class com.netflix.governator.LifecycleInjector -->
  <class name="LifecycleInjector" extends="com.netflix.governator.DelegatingInjector"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="createFailedInjector" return="com.netflix.governator.LifecycleInjector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="manager" type="com.netflix.governator.LifecycleManager"/>
    </method>
    <method name="wrapInjector" return="com.netflix.governator.LifecycleInjector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="Injector"/>
      <param name="manager" type="com.netflix.governator.LifecycleManager"/>
    </method>
    <method name="awaitTermination"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Block until LifecycleManager terminates
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Shutdown LifecycleManager on this Injector which will invoke all registered
 {@link LifecycleListener}s and unblock awaitTermination.]]>
      </doc>
    </method>
    <method name="addListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.netflix.governator.spi.LifecycleListener"/>
      <doc>
      <![CDATA[Register a single shutdown listener for async notification of the LifecycleManager
 terminating. 
 @param listener]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Wrapper for Guice's Injector with added shutdown methods.  
 
 <b>Invoking shutdown from outside the injector</b>
 <pre>
 <code>
    LifecycleInjector injector = new Governator().run();
    // ...
    injector.shutdown();
 </code>
 </pre>
 
 <b>Blocking on the injector terminating</b>
 <pre>
 <code>
    LifecycleInjector injector = new Governator().run(;
    // ...
    injector.awaitTermination();
 </code>
 </pre>
 
 <b>Triggering shutdown from a DI'd class</b>
 <pre>
 <code>
    {@literal @}Singleton
    public class SomeShutdownService {
        {@literal @}Inject
        SomeShutdownService(LifecycleManager lifecycleManager) {
            this.lifecycleManager = lifecycleManager;
        }
      
        void someMethodInvokedForShutdown() {
            this.lifecycleManager.shutdown();
        }
    }
 }
 </code>
 </pre>
 
 <b>Triggering an external event from shutdown without blocking</b>
 <pre>
 <code>
    LifecycleInjector injector = new Governator().run(;
    injector.addListener(new LifecycleListener() {
        public void onShutdown() {
            // Do your shutdown handling here
        }
    });
 }
 </code>
 </pre>]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.LifecycleInjector -->
  <!-- start class com.netflix.governator.LifecycleInjectorCreator -->
  <class name="LifecycleInjectorCreator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.spi.InjectorCreator&lt;com.netflix.governator.LifecycleInjector&gt;"/>
    <constructor name="LifecycleInjectorCreator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="withArguments" return="com.netflix.governator.LifecycleInjectorCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
    </method>
    <method name="withProfiles" return="com.netflix.governator.LifecycleInjectorCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profiles" type="java.lang.String[]"/>
    </method>
    <method name="withProfiles" return="com.netflix.governator.LifecycleInjectorCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="profiles" type="java.util.Set&lt;java.lang.String&gt;"/>
    </method>
    <method name="withFeatures" return="com.netflix.governator.LifecycleInjectorCreator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="features" type="java.util.IdentityHashMap&lt;com.netflix.governator.GovernatorFeature&lt;?&gt;, java.lang.Object&gt;"/>
    </method>
    <method name="createInjector" return="com.netflix.governator.LifecycleInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="Stage"/>
      <param name="module" type="Module"/>
    </method>
    <method name="onBeforeInjectorCreate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Template method invoked immediately before the injector is created]]>
      </doc>
    </method>
    <method name="onSuccessfulInjectorCreate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Template method invoked immediately after the injector is created]]>
      </doc>
    </method>
    <method name="onFailedInjectorCreate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="error" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Template method invoked immediately after any failure to create the injector
 @param error Cause of the failure]]>
      </doc>
    </method>
    <method name="onCompletedInjectorCreate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Template method invoked at the end of createInjector() regardless of whether
 the injector was created successful or not.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Custom strategy for creating a Guice Injector that enables support for lifecycle annotations such 
 as {@link @PreDestroy} and {@link @PostConstruct} as well as injector lifecycle hooks via the 
 {@link LifecycleListener} API. 
 
 The LifecycleInjectorCreator may be overridden to handle pre-create and post-create notification.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.LifecycleInjectorCreator -->
  <!-- start interface com.netflix.governator.LifecycleListener -->
  <interface name="LifecycleListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="2015-12-15 Use com.netflix.governator.api.LifecycleListener instead">
    <implements name="com.netflix.governator.spi.LifecycleListener"/>
    <doc>
    <![CDATA[@deprecated 2015-12-15 Use com.netflix.governator.api.LifecycleListener instead]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.LifecycleListener -->
  <!-- start class com.netflix.governator.LifecycleManager -->
  <class name="LifecycleManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LifecycleManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addListener"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="listener" type="com.netflix.governator.spi.LifecycleListener"/>
    </method>
    <method name="notifyStarted"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="notifyStartFailed"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="notifyShutdown"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getState" return="com.netflix.governator.LifecycleManager.State"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFailureReason" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Manage state for lifecycle listeners
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.LifecycleManager -->
  <!-- start class com.netflix.governator.LifecycleManager.State -->
  <class name="LifecycleManager.State" extends="java.lang.Enum&lt;com.netflix.governator.LifecycleManager.State&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.netflix.governator.LifecycleManager.State[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.netflix.governator.LifecycleManager.State"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.LifecycleManager.State -->
  <!-- start class com.netflix.governator.LifecycleModule -->
  <class name="LifecycleModule" extends="AbstractModule"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="LifecycleModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Adds support for standard lifecycle annotations @PostConstruct and @PreDestroy to Guice.
 
 <code>
 public class MyService {
    {@literal @}PostConstruct
    public void init() {
    }
    
    {@literal @}PreDestroy
    public void shutdown() {
    }
 }
 </code>
 
 To use simply add LifecycleModule to guice when creating the injector
 
 See {@link LifecycleInjector} for different scenarios for shutting down the LifecycleManager.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.LifecycleModule -->
  <!-- start interface com.netflix.governator.LifecycleShutdownSignal -->
  <interface name="LifecycleShutdownSignal"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="signal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Signal shutdown]]>
      </doc>
    </method>
    <method name="await"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Wait for shutdown to be signalled.  This could be either the result of 
 calling signal() or an internal shutdown mechanism for the container.
 
 @throws InterruptedException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Shutdown signal for the lifecycle manager.  Code can either block on the signal
 being fired or trigger it from a shutdown mechanism, such as a shutdown PID or
 shutdown socket.  Each container is likely to have it's own implementation of
 shutdown signal.
 
 @author elandau]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.LifecycleShutdownSignal -->
  <!-- start class com.netflix.governator.LoggingProvisionMetricsLifecycleListener -->
  <class name="LoggingProvisionMetricsLifecycleListener" extends="com.netflix.governator.AbstractLifecycleListener"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onStarted"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="onStopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.LoggingProvisionMetricsLifecycleListener -->
  <!-- start class com.netflix.governator.LoggingProvisionMetricsVisitor -->
  <class name="LoggingProvisionMetricsVisitor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.ProvisionMetrics.Visitor"/>
    <constructor name="LoggingProvisionMetricsVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entry" type="com.netflix.governator.ProvisionMetrics.Element"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.LoggingProvisionMetricsVisitor -->
  <!-- start class com.netflix.governator.NullProvisionMetrics -->
  <class name="NullProvisionMetrics" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.ProvisionMetrics"/>
    <constructor name="NullProvisionMetrics"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="push"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="&lt;any&gt;"/>
    </method>
    <method name="pop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="accept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.netflix.governator.ProvisionMetrics.Visitor"/>
    </method>
    <doc>
    <![CDATA[Default NoOp implementation of ProvisionMetrics.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.NullProvisionMetrics -->
  <!-- start class com.netflix.governator.PropertiesPropertySource -->
  <class name="PropertiesPropertySource" extends="com.netflix.governator.AbstractPropertySource"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PropertiesPropertySource" type="java.util.Properties"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PropertiesPropertySource"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="from" return="com.netflix.governator.PropertiesPropertySource"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="props" type="java.util.Properties"/>
    </method>
    <method name="setProperty" return="com.netflix.governator.PropertiesPropertySource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="hasProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
    </method>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="Binder"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Implementation of a PropertySource using a standard {@link Properties} object.
 
 PropertiesPropertySource is also a Guice module and can be installed to provide a
 self binding to PropertySource.class.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.PropertiesPropertySource -->
  <!-- start class com.netflix.governator.ProvisionDebugModule -->
  <class name="ProvisionDebugModule" extends="com.netflix.governator.SingletonModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProvisionDebugModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Install this module to log a Provision report after the Injector is created.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.ProvisionDebugModule -->
  <!-- start class com.netflix.governator.ProvisionDebugModule.StaticInitializer -->
  <class name="ProvisionDebugModule.StaticInitializer" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StaticInitializer"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="listener" type="com.netflix.governator.LoggingProvisionMetricsLifecycleListener"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.netflix.governator.ProvisionDebugModule.StaticInitializer -->
  <!-- start interface com.netflix.governator.ProvisionMetrics -->
  <interface name="ProvisionMetrics"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="push"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[Notification that an object of type 'key' is about to be created.
 Note that there will likely be several nested calls to push() as
 dependencies are injected.
 @param key]]>
      </doc>
    </method>
    <method name="pop"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Pop and finalize initialization of the latest object to be provisioned.
 A matching pop will be called for each push().]]>
      </doc>
    </method>
    <method name="accept"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.netflix.governator.ProvisionMetrics.Visitor"/>
      <doc>
      <![CDATA[Traverse the elements using the visitor pattern.
 @param visitor]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface invoked by LifecycleModule's ProvisionListener to 
 gather metrics on objects as they are provisioned.  Through the
 provision listener it's possible to generate a dependency tree
 for the first initialization of all objects.  Note that no call
 will be made for singletons that are being injected but have 
 already been instantiated.
 
 @author elandau]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.ProvisionMetrics -->
  <!-- start interface com.netflix.governator.ProvisionMetrics.Element -->
  <interface name="ProvisionMetrics.Element"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getKey" return="&lt;any&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDuration" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="units" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getTotalDuration" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="units" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="accept"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.netflix.governator.ProvisionMetrics.Visitor"/>
    </method>
    <doc>
    <![CDATA[Node used to track metrics for an object that has been provisioned
 @author elandau]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.ProvisionMetrics.Element -->
  <!-- start interface com.netflix.governator.ProvisionMetrics.Visitor -->
  <interface name="ProvisionMetrics.Visitor"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="visit"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="com.netflix.governator.ProvisionMetrics.Element"/>
    </method>
    <doc>
    <![CDATA[Visitor API for traversing nodes
 @author elandau]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.ProvisionMetrics.Visitor -->
  <!-- start class com.netflix.governator.ProvisionMetricsModule -->
  <class name="ProvisionMetricsModule" extends="AbstractModule"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ProvisionMetricsModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.netflix.governator.ProvisionMetricsModule -->
  <!-- start class com.netflix.governator.ServiceLoaderModuleBuilder -->
  <class name="ServiceLoaderModuleBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceLoaderModuleBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="usingClassLoader" return="com.netflix.governator.ServiceLoaderModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classLoader" type="java.lang.ClassLoader"/>
    </method>
    <method name="forInstalledServices" return="com.netflix.governator.ServiceLoaderModuleBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="installed" type="java.lang.Boolean"/>
    </method>
    <method name="loadModules" return="Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;S&gt;"/>
    </method>
    <method name="loadServices" return="Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;S&gt;"/>
    </method>
    <doc>
    <![CDATA[Builder for creating a Guice module that either installs modules loaded from the
 service loader or creates multibindings for a service type.  Method and field @Inject
 methods of the services will also be invoked.
 
 @author elandau

 TODO:  Lazy member injection]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.ServiceLoaderModuleBuilder -->
  <!-- start class com.netflix.governator.ShutdownHookModule -->
  <class name="ShutdownHookModule" extends="AbstractModule"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ShutdownHookModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[When installed ShutdownHookModule will link a JVM shutdown hook to
 LifecycleManager so that calling System.exit() will shutdown 
 it down.
 
 <pre>
 {@code
    Governator.createInjector(new LifecycleModule(), new ShutdownHookModule());
 }
 </pre>]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.ShutdownHookModule -->
  <!-- start class com.netflix.governator.ShutdownHookModule.SystemShutdownHook -->
  <class name="ShutdownHookModule.SystemShutdownHook" extends="java.lang.Thread"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SystemShutdownHook" type="com.netflix.governator.LifecycleShutdownSignal"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.netflix.governator.ShutdownHookModule.SystemShutdownHook -->
  <!-- start class com.netflix.governator.SimpleInjectorCreator -->
  <class name="SimpleInjectorCreator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.spi.InjectorCreator&lt;Injector&gt;"/>
    <constructor name="SimpleInjectorCreator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createInjector" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="Stage"/>
      <param name="module" type="Module"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.SimpleInjectorCreator -->
  <!-- start class com.netflix.governator.SimpleProvisionMetrics -->
  <class name="SimpleProvisionMetrics" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.ProvisionMetrics"/>
    <constructor name="SimpleProvisionMetrics"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="push"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
    </method>
    <method name="pop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="accept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="com.netflix.governator.ProvisionMetrics.Visitor"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.SimpleProvisionMetrics -->
  <!-- start class com.netflix.governator.SimpleProvisionMetrics.Data -->
  <class name="SimpleProvisionMetrics.Data" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Data"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.netflix.governator.SimpleProvisionMetrics.Data -->
  <!-- start class com.netflix.governator.SimpleProvisionMetrics.Entry -->
  <class name="SimpleProvisionMetrics.Entry" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.ProvisionMetrics.Element"/>
    <method name="getKey" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="accept"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visit" type="com.netflix.governator.ProvisionMetrics.Visitor"/>
    </method>
    <method name="getDuration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="units" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getTotalDuration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="units" type="java.util.concurrent.TimeUnit"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.SimpleProvisionMetrics.Entry -->
  <!-- start class com.netflix.governator.SingletonModule -->
  <class name="SingletonModule" extends="AbstractModule"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SingletonModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base module that ensures only one module is used when multiple modules
 are installed using the concrete module class as the dedup key.  To 
 ensure 'best practices' this class also forces the concrete module to
 be final.  This is done to prevent the use of inheritance for overriding
 behavior in favor of using Modules.override().
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.SingletonModule -->
</package>
<package name="com.netflix.governator.annotations">
  <!-- start class com.netflix.governator.annotations.AutoBind -->
  <class name="AutoBind"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="2015-10-10 Deprecated in favor of standard Guice modules. 
             See https://github.com/Netflix/governator/wiki/Auto-Binding">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Annotation binding that combines with Governator's classpath scanning and a bound
 AutoBindProvider to automatically/programmatically bind fields and constructor/method
 arguments
 
 @deprecated 2015-10-10 Deprecated in favor of standard Guice modules. 
             See https://github.com/Netflix/governator/wiki/Auto-Binding]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.AutoBind -->
  <!-- start class com.netflix.governator.annotations.AutoBindSingleton -->
  <class name="AutoBindSingleton"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="2015-10-10 AutoBindSingleton is deprecated in favor of bindings in a Guice Module.
              See https://github.com/Netflix/governator/wiki/Auto-Binding">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Marks a class as a singleton. Governator will auto-bind it as an eager singleton
 @deprecated  2015-10-10 AutoBindSingleton is deprecated in favor of bindings in a Guice Module.
              See https://github.com/Netflix/governator/wiki/Auto-Binding]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.AutoBindSingleton -->
  <!-- start class com.netflix.governator.annotations.Configuration -->
  <class name="Configuration"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Marks a field as a configuration item. Governator will auto-assign the value based
 on the {@link #value()} of the annotation via the set com.netflix.governator.configurationConfigurationProvider.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.Configuration -->
  <!-- start class com.netflix.governator.annotations.ConfigurationVariable -->
  <class name="ConfigurationVariable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.ConfigurationVariable -->
  <!-- start class com.netflix.governator.annotations.Modules -->
  <class name="Modules"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.Modules -->
  <!-- start class com.netflix.governator.annotations.NonConcurrent -->
  <class name="NonConcurrent"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Used to indicate that a constructor argument cannot be constructed concurrently.
 Use this in conjunction with {@link ConcurrentProviders.of()} when instantiating
 an injected dependency in parallel results in the guice @Singleton scope deadlock.
 
 @see {@link ConcurrentProviders}
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.NonConcurrent -->
  <!-- start class com.netflix.governator.annotations.PreConfiguration -->
  <class name="PreConfiguration"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Marks a method as a pre-configuration method. Governator will execute pre-configuration methods
 prior to configuration assignment]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.PreConfiguration -->
  <!-- start class com.netflix.governator.annotations.SuppressLifecycleUninitialized -->
  <class name="SuppressLifecycleUninitialized"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.SuppressLifecycleUninitialized -->
  <!-- start class com.netflix.governator.annotations.WarmUp -->
  <class name="WarmUp"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Marks a method as a warm up method. Governator will execute warm up methods
 in parallel when the com.netflix.governator.lifecycle.LifecycleManager is started.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.WarmUp -->
</package>
<package name="com.netflix.governator.annotations.binding">
  <!-- start class com.netflix.governator.annotations.binding.Arguments -->
  <class name="Arguments"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Qualifier associated with String[] arguments passed to Karyon.start(args)]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Arguments -->
  <!-- start class com.netflix.governator.annotations.binding.Background -->
  <class name="Background"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Background -->
  <!-- start class com.netflix.governator.annotations.binding.Color -->
  <class name="Color"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Color -->
  <!-- start class com.netflix.governator.annotations.binding.Computation -->
  <class name="Computation"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Computation -->
  <!-- start class com.netflix.governator.annotations.binding.Context -->
  <class name="Context"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Context -->
  <!-- start class com.netflix.governator.annotations.binding.DataCenter -->
  <class name="DataCenter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A generic binding annotation normally used to bind the DataCenter name. 
 
 Internally at Netflix Datacenter is set to 'cloud' for amazon and 'dc' for a
 traditional datacenter.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.DataCenter -->
  <!-- start class com.netflix.governator.annotations.binding.DownStatus -->
  <class name="DownStatus"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Generic annotation that is equivalent to !{@link UpStatus}.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.DownStatus -->
  <!-- start class com.netflix.governator.annotations.binding.Input -->
  <class name="Input"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Input -->
  <!-- start class com.netflix.governator.annotations.binding.IO -->
  <class name="IO"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.IO -->
  <!-- start class com.netflix.governator.annotations.binding.Main -->
  <class name="Main"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Main -->
  <!-- start class com.netflix.governator.annotations.binding.Major -->
  <class name="Major"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Major -->
  <!-- start class com.netflix.governator.annotations.binding.Message -->
  <class name="Message"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Message -->
  <!-- start class com.netflix.governator.annotations.binding.Minor -->
  <class name="Minor"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Minor -->
  <!-- start class com.netflix.governator.annotations.binding.Mode -->
  <class name="Mode"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Mode -->
  <!-- start class com.netflix.governator.annotations.binding.Option -->
  <class name="Option"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Option -->
  <!-- start class com.netflix.governator.annotations.binding.Output -->
  <class name="Output"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Output -->
  <!-- start class com.netflix.governator.annotations.binding.Primary -->
  <class name="Primary"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Primary -->
  <!-- start class com.netflix.governator.annotations.binding.Profiles -->
  <class name="Profiles"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Qualifier associated with Set{@literal <}String{@literal >} of active profiles]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Profiles -->
  <!-- start class com.netflix.governator.annotations.binding.Rack -->
  <class name="Rack"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A generic binding annotation normally used to bind the rack id.
 For AWS Rack should be used to bind the Zone name.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Rack -->
  <!-- start class com.netflix.governator.annotations.binding.Region -->
  <class name="Region"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A generic binding annotation normally used to bind the region id.
 For AWS Region can be 'us-east', 'us-west-2', etc.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Region -->
  <!-- start class com.netflix.governator.annotations.binding.Request -->
  <class name="Request"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Request -->
  <!-- start class com.netflix.governator.annotations.binding.Response -->
  <class name="Response"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Response -->
  <!-- start class com.netflix.governator.annotations.binding.Secondary -->
  <class name="Secondary"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Secondary -->
  <!-- start class com.netflix.governator.annotations.binding.Size -->
  <class name="Size"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Size -->
  <!-- start class com.netflix.governator.annotations.binding.State -->
  <class name="State"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.State -->
  <!-- start class com.netflix.governator.annotations.binding.Status -->
  <class name="Status"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Status -->
  <!-- start class com.netflix.governator.annotations.binding.Style -->
  <class name="Style"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Style -->
  <!-- start class com.netflix.governator.annotations.binding.Subsidiary -->
  <class name="Subsidiary"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.Subsidiary -->
  <!-- start class com.netflix.governator.annotations.binding.UpStatus -->
  <class name="UpStatus"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[A generic binding annotation that can be associated with the up status
 of an application.

 <pre>
  bind(Boolean.class).annotatedWith(UpStatus.class).toInstance(new AtomicBoolean(true));
  bind(new TypeLiteral<Supplier<Boolean>() {}>).annotatedWith(UpStatus.class).toInstance(new SomeSupplierThatTellsYouTheUpStatus());

  public class Foo() {
     &#64;Inject
     public Foo(@UpStatus Supplier<Boolean> isUp) {
        System.out.println("Application isUp: " + isUp);
     }
  }
 </pre>

 If you're using RxJava you can set up an Observable of up status
 <pre>
  bind(new TypeLiteral<Observable<Boolean>>() {}>).annotatedWith(UpStatus.class).toInstance(new SomethingThatEmitsChangesInUpStatus());

  public class Foo() {
     &#64;Inject
     public Foo(@UpStatus Observable<Boolean> upStatus) {
         upStatus.subscribe(new Action1<Boolean>() {
             public void call(Boolean status) {
                 System.out.println("Status is now up");
             }
         });
     }
  }

 @see DownStatus
 </pre>]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.annotations.binding.UpStatus -->
</package>
<package name="com.netflix.governator.commons_cli">
  <!-- start class com.netflix.governator.commons_cli.Cli -->
  <class name="Cli" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Cli"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mainClass" type="java.lang.Class&lt;?&gt;"/>
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Utility method to start the CommonsCli using a main class and command line arguments
 
 @param mainClass
 @param args]]>
      </doc>
    </method>
  </class>
  <!-- end class com.netflix.governator.commons_cli.Cli -->
</package>
<package name="com.netflix.governator.commons_cli.modules">
  <!-- start class com.netflix.governator.commons_cli.modules.OptionsModule -->
  <class name="OptionsModule" extends="AbstractModule"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="OptionsModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="configureOptions"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="option" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="shortopt" type="char"/>
      <doc>
      <![CDATA[@param shortopt
 @return Return a builder through which a single option may be configured]]>
      </doc>
    </method>
    <method name="bindParser" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Bind any parser.  BasicParser is used by default if no other parser is provided.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Guicify Apache Commons CLI.  
 
 Usages
 
 <pre>
 {code
 
 // When creating Guice
 
 install(new OptionsModule() {
    protected void configure() {
       option("f")
          .hasArg()
          .withLongOpt("filename")
          .annotatedWith(Filename.class);  // no need to call create()
          
    }
 })
 
 // Inject into any class
 
 @Singleton 
 public class MyService {
    @Inject
    public MyService(@Filename String filename) {
    }
 }
 
 // You can also inject CommandLine directly
 
 @Singleton
 public class MyService {
    @Inject
    public MyService(CommandLine commandLine) {
    }
 }
 
 }
 </pre>
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.commons_cli.modules.OptionsModule -->
  <!-- start class com.netflix.governator.commons_cli.modules.OptionsModule.CommandLineProvider -->
  <class name="OptionsModule.CommandLineProvider" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CommandLineProvider" type="Options, java.lang.String[], Parser"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="CommandLine"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[On injection of CommandLine execute the BasicParser
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.commons_cli.modules.OptionsModule.CommandLineProvider -->
  <!-- start class com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder -->
  <class name="OptionsModule.OptionBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="protected"
    deprecated="not deprecated">
    <constructor name="OptionBuilder"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="annotatedWith" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annot" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
    </method>
    <method name="withLongOpt" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="longopt" type="java.lang.String"/>
    </method>
    <method name="withShortOpt" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="shortopt" type="char"/>
    </method>
    <method name="hasArg" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasArg" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hasArg" type="boolean"/>
    </method>
    <method name="withArgName" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="isRequired" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="withValueSeparator" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sep" type="char"/>
    </method>
    <method name="withValueSeparator" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isRequired" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newRequired" type="boolean"/>
    </method>
    <method name="hasArgs" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasArgs" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="num" type="int"/>
    </method>
    <method name="hasOptionalArg" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasOptionalArgs" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasOptionalArgs" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="numArgs" type="int"/>
    </method>
    <method name="withType" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newType" type="java.lang.Object"/>
    </method>
    <method name="withDescription" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="newDescription" type="java.lang.String"/>
    </method>
    <method name="withDefaultValue" return="com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="defaultValue" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Non-static version of commons CLI OptionBuilder
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.commons_cli.modules.OptionsModule.OptionBuilder -->
</package>
<package name="com.netflix.governator.commons_cli.providers">
  <!-- start class com.netflix.governator.commons_cli.providers.StringOptionProvider -->
  <class name="StringOptionProvider" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StringOptionProvider" type="Option, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptExtensionVisitor" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="&lt;any&gt;"/>
      <param name="binding" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[This is needed for 'initialize(injector)' below to be called so the provider
 can get the injector after it is instantiated.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Custom provider that bridges an Option with an injectable String for the option value
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.commons_cli.providers.StringOptionProvider -->
</package>
<package name="com.netflix.governator.configuration">
  <!-- start class com.netflix.governator.configuration.AbstractObjectConfigurationProvider -->
  <class name="AbstractObjectConfigurationProvider" extends="com.netflix.governator.configuration.DefaultConfigurationProvider"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractObjectConfigurationProvider"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AbstractObjectConfigurationProvider" type="ObjectMapper"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <method name="getObjectProperty" return="com.netflix.governator.configuration.Property&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="T"/>
      <param name="objectType" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[Implements the deserialization part of {@link ConfigurationProvider} to simplify implementations.

 Created by jad.naous on 4/2/14.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.AbstractObjectConfigurationProvider -->
  <!-- start class com.netflix.governator.configuration.ArchaiusConfigurationProvider -->
  <class name="ArchaiusConfigurationProvider" extends="com.netflix.governator.configuration.AbstractObjectConfigurationProvider"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ArchaiusConfigurationProvider"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ArchaiusConfigurationProvider" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="builder" return="com.netflix.governator.configuration.ArchaiusConfigurationProvider.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDynamicProperty" return="com.netflix.governator.configuration.Property&lt;?&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <param name="key" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <param name="propertyFactory" type="DynamicPropertyFactory"/>
    </method>
    <method name="setVariable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Change a variable value

 @param name  name
 @param value value]]>
      </doc>
    </method>
    <method name="has" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
    </method>
    <method name="getBooleanProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Boolean"/>
    </method>
    <method name="getIntegerProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Integer"/>
    </method>
    <method name="getLongProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Long"/>
    </method>
    <method name="getDoubleProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Double"/>
    </method>
    <method name="getStringProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.String"/>
    </method>
    <method name="getDateProperty" return="com.netflix.governator.configuration.Property&lt;java.util.Date&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.util.Date"/>
    </method>
    <doc>
    <![CDATA[Configuration provider backed by Netflix Archaius (https://github.com/Netflix/archaius)]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.ArchaiusConfigurationProvider -->
  <!-- start class com.netflix.governator.configuration.ArchaiusConfigurationProvider.Builder -->
  <class name="ArchaiusConfigurationProvider.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="withVariableValues" return="com.netflix.governator.configuration.ArchaiusConfigurationProvider.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="variableValues" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[Set of variables to use when expanding property key names]]>
      </doc>
    </method>
    <method name="withConfigurationManager" return="com.netflix.governator.configuration.ArchaiusConfigurationProvider.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configurationManager" type="AbstractConfiguration"/>
      <doc>
      <![CDATA[Archaius configuration manager to use.  Defaults to ConfigurationManager.getConfigInstance()]]>
      </doc>
    </method>
    <method name="withPropertyFactory" return="com.netflix.governator.configuration.ArchaiusConfigurationProvider.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propertyFactory" type="DynamicPropertyFactory"/>
      <doc>
      <![CDATA[Dynamic property factory to use for Supplier<?> attributes.  Defaults to DynamicPropertyFactory.getInstance()]]>
      </doc>
    </method>
    <method name="withOwnershipPolicy" return="com.netflix.governator.configuration.ArchaiusConfigurationProvider.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="policy" type="com.netflix.governator.configuration.ConfigurationOwnershipPolicy"/>
      <doc>
      <![CDATA[When set to true this configuration provider will 'have' all properties regardless of whether they
 have been set yet or not.  This is very important for dynamic properties that have a default value
 but haven't been overriden yet.]]>
      </doc>
    </method>
    <method name="withObjectMapper" return="com.netflix.governator.configuration.ArchaiusConfigurationProvider.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectMapper" type="ObjectMapper"/>
    </method>
    <method name="build" return="com.netflix.governator.configuration.ArchaiusConfigurationProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.netflix.governator.configuration.ArchaiusConfigurationProvider.Builder -->
  <!-- start class com.netflix.governator.configuration.ArchaiusConfigurationProvider.PropertyWrapperProperty -->
  <class name="ArchaiusConfigurationProvider.PropertyWrapperProperty" extends="com.netflix.governator.configuration.Property&lt;T&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PropertyWrapperProperty" type="&lt;any&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Adapter to convert Archaius internal PropertyWrapper to a standard Guava supplier

 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.ArchaiusConfigurationProvider.PropertyWrapperProperty -->
  <!-- start class com.netflix.governator.configuration.CompositeConfigurationProvider -->
  <class name="CompositeConfigurationProvider" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.configuration.ConfigurationProvider"/>
    <constructor name="CompositeConfigurationProvider" type="com.netflix.governator.configuration.ConfigurationProvider[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param providers ordered providers]]>
      </doc>
    </constructor>
    <constructor name="CompositeConfigurationProvider" type="java.util.Collection&lt;com.netflix.governator.configuration.ConfigurationProvider&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param providers ordered providers]]>
      </doc>
    </constructor>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configurationProvider" type="com.netflix.governator.configuration.ConfigurationProvider"/>
    </method>
    <method name="has" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
    </method>
    <method name="getBooleanSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Boolean"/>
    </method>
    <method name="getIntegerSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Integer"/>
    </method>
    <method name="getLongSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Long"/>
    </method>
    <method name="getDoubleSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Double"/>
    </method>
    <method name="getStringSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.String"/>
    </method>
    <method name="getDateSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.util.Date"/>
    </method>
    <method name="getObjectSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="T"/>
      <param name="objectType" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[A configuration provider that composites multiple providers. The first
 provider (in order) that has a configuration set (via {@link #has(ConfigurationKey)} is used
 to return the configuration.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.CompositeConfigurationProvider -->
  <!-- start class com.netflix.governator.configuration.ConfigurationColumnWriter -->
  <class name="ConfigurationColumnWriter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigurationColumnWriter" type="com.netflix.governator.configuration.ConfigurationDocumentation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="output"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="log" type="Logger"/>
      <doc>
      <![CDATA[Write the documentation table to a logger
 @param log]]>
      </doc>
    </method>
    <method name="output"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Write the documentation table to System.out]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simple implementation of a configuration writer that outputs in column format
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.ConfigurationColumnWriter -->
  <!-- start class com.netflix.governator.configuration.ConfigurationDocumentation -->
  <class name="ConfigurationDocumentation" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigurationDocumentation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="registerConfiguration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="field" type="java.lang.reflect.Field"/>
      <param name="configurationName" type="java.lang.String"/>
      <param name="has" type="boolean"/>
      <param name="defaultValue" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="documentation" type="java.lang.String"/>
    </method>
    <method name="getSortedEntries" return="java.util.Map&lt;java.lang.String, com.netflix.governator.configuration.ConfigurationDocumentation.Entry&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Used internally to display configuration documentation]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.ConfigurationDocumentation -->
  <!-- start class com.netflix.governator.configuration.ConfigurationDocumentation.Entry -->
  <class name="ConfigurationDocumentation.Entry" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <field name="field" type="java.lang.reflect.Field"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="configurationName" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="has" type="boolean"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="defaultValue" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="value" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="documentation" type="java.lang.String"
      transient="false" volatile="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.netflix.governator.configuration.ConfigurationDocumentation.Entry -->
  <!-- start class com.netflix.governator.configuration.ConfigurationKey -->
  <class name="ConfigurationKey" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigurationKey" type="java.lang.String, java.util.List&lt;com.netflix.governator.configuration.ConfigurationKeyPart&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param rawKey the unprocessed value
 @param parts  the parsed values]]>
      </doc>
    </constructor>
    <method name="getRawKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the unprocessed key]]>
      </doc>
    </method>
    <method name="getKey" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="variableValues" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[Return the final key applying variables as needed

 @param variableValues map of variable names to values
 @return the key]]>
      </doc>
    </method>
    <method name="getParts" return="java.util.List&lt;com.netflix.governator.configuration.ConfigurationKeyPart&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the parsed key parts]]>
      </doc>
    </method>
    <method name="getVariableNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the names of the variables specified in the key if any

 @return names (might be zero sized)]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Abstracts configuration names with variable replacements]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.ConfigurationKey -->
  <!-- start class com.netflix.governator.configuration.ConfigurationKeyPart -->
  <class name="ConfigurationKeyPart" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConfigurationKeyPart" type="java.lang.String, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param value    the string or variable name
 @param variable true if this is a variable substitution]]>
      </doc>
    </constructor>
    <method name="getValue" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the name or variable name]]>
      </doc>
    </method>
    <method name="isVariable" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return true if this is a variable substitution]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A portion of a configuration name]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.ConfigurationKeyPart -->
  <!-- start interface com.netflix.governator.configuration.ConfigurationMapper -->
  <interface name="ConfigurationMapper"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="mapConfiguration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configurationProvider" type="com.netflix.governator.configuration.ConfigurationProvider"/>
      <param name="configurationDocumentation" type="com.netflix.governator.configuration.ConfigurationDocumentation"/>
      <param name="obj" type="java.lang.Object"/>
      <param name="methods" type="com.netflix.governator.lifecycle.LifecycleMethods"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[Interface definition for mapping a configuration on an instance
 
 TODO:  Ideally ConfigurationProvider and ConfigurationDocumentation should 
        be specific to the specific configuration mapper implementation
 
 @author elandau]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.configuration.ConfigurationMapper -->
  <!-- start class com.netflix.governator.configuration.ConfigurationOwnershipPolicies -->
  <class name="ConfigurationOwnershipPolicies" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="ownsAll" return="com.netflix.governator.configuration.ConfigurationOwnershipPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return an ownership policy that returns true for {@link ConfigurationOwnershipPolicy#has(ConfigurationKey, Map)}

 @return policy]]>
      </doc>
    </method>
    <method name="ownsByRegex" return="com.netflix.governator.configuration.ConfigurationOwnershipPolicy"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <doc>
      <![CDATA[Return an ownership policy that returns true for {@link ConfigurationOwnershipPolicy#has(ConfigurationKey, Map)}
 when the given regular expression matches

 @return regex policy]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Convenience factory for getting standard ownership policies]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.ConfigurationOwnershipPolicies -->
  <!-- start interface com.netflix.governator.configuration.ConfigurationOwnershipPolicy -->
  <interface name="ConfigurationOwnershipPolicy"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="has" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="variableValues" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[Return true if there is a configuration value set for the given key + variables

 @param key configuration key
 @param variableValues map of variable names to values
 @return true/false]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Policy to determine if a configuration key is owned by a ConfigurationProvider

 @author elandau]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.configuration.ConfigurationOwnershipPolicy -->
  <!-- start interface com.netflix.governator.configuration.ConfigurationProvider -->
  <interface name="ConfigurationProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="has" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <doc>
      <![CDATA[Return true if there is a configuration value set for the given key

 @param key configuration key
 @return true/false]]>
      </doc>
    </method>
    <method name="getBooleanSupplier" return="&lt;any&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Boolean"/>
      <doc>
      <![CDATA[Return the given configuration as a boolean.  Use this when the configuration
 value is expected to change at run time.

 @param key configuration key
 @return value]]>
      </doc>
    </method>
    <method name="getIntegerSupplier" return="&lt;any&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Integer"/>
      <doc>
      <![CDATA[Return the given configuration as an integer.   Use this when the configuration
 value is expected to change at run time.

 @param key configuration key
 @return value]]>
      </doc>
    </method>
    <method name="getLongSupplier" return="&lt;any&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Long"/>
      <doc>
      <![CDATA[Return the given configuration as a long.  Use this when the configuration
 value is expected to change at run time.

 @param key configuration key
 @return value]]>
      </doc>
    </method>
    <method name="getDoubleSupplier" return="&lt;any&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Double"/>
      <doc>
      <![CDATA[Return the given configuration as a double.  Use this when the configuration
 value is expected to change at run time.

 @param key configuration key
 @return value]]>
      </doc>
    </method>
    <method name="getStringSupplier" return="&lt;any&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Return the given configuration as a string.  Use this when the configuration
 value is expected to change at run time.

 @param key configuration key
 @return value]]>
      </doc>
    </method>
    <method name="getDateSupplier" return="&lt;any&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.util.Date"/>
      <doc>
      <![CDATA[Return the given configuration as a date.  Use this when the configuration
 value is expected to change at run time.

 @param key configuration key
 @return value]]>
      </doc>
    </method>
    <method name="getObjectSupplier" return="&lt;any&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="T"/>
      <param name="objectType" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Return the given configuration as an object of the given type.

 @param key             configuration key
 @param defaultValue    value to return when key is not found
 @param objectType      Class of the configuration to return
 @param <T>             type of the configuration to return
 @return the object for this configuration.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstraction for get configuration values to use for fields annotated
 with {@link Configuration}]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.configuration.ConfigurationProvider -->
  <!-- start class com.netflix.governator.configuration.DateWithDefaultProperty -->
  <class name="DateWithDefaultProperty" extends="com.netflix.governator.configuration.Property&lt;java.util.Date&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DateWithDefaultProperty" type="com.netflix.governator.configuration.Property&lt;java.lang.String&gt;, java.util.Date"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.util.Date"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Special supplier that converts a string date to a Date

 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.DateWithDefaultProperty -->
  <!-- start class com.netflix.governator.configuration.DateWithDefaultSupplier -->
  <class name="DateWithDefaultSupplier" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DateWithDefaultSupplier" type="&lt;any&gt;, java.util.Date"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.util.Date"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Special supplier that converts a string date to a Date

 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.DateWithDefaultSupplier -->
  <!-- start class com.netflix.governator.configuration.DefaultConfigurationProvider -->
  <class name="DefaultConfigurationProvider" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.configuration.ConfigurationProvider"/>
    <constructor name="DefaultConfigurationProvider"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="has" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
    </method>
    <method name="getBooleanSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Boolean"/>
    </method>
    <method name="getIntegerSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Integer"/>
    </method>
    <method name="getLongSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Long"/>
    </method>
    <method name="getDoubleSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Double"/>
    </method>
    <method name="getStringSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.String"/>
    </method>
    <method name="getDateSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.util.Date"/>
    </method>
    <method name="getObjectSupplier" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="T"/>
      <param name="objectType" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="getBooleanProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Boolean&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Boolean"/>
    </method>
    <method name="getIntegerProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Integer&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Integer"/>
    </method>
    <method name="getLongProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Long&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Long"/>
    </method>
    <method name="getDoubleProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Double&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Double"/>
    </method>
    <method name="getStringProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.String&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.String"/>
    </method>
    <method name="getDateProperty" return="com.netflix.governator.configuration.Property&lt;java.util.Date&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.util.Date"/>
    </method>
    <method name="getObjectProperty" return="com.netflix.governator.configuration.Property&lt;T&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="T"/>
      <param name="objectType" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[This is a hack in preparation for removing Supplier from the API.  
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.DefaultConfigurationProvider -->
  <!-- start class com.netflix.governator.configuration.KeyParser -->
  <class name="KeyParser" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="parse" return="java.util.List&lt;com.netflix.governator.configuration.ConfigurationKeyPart&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="raw" type="java.lang.String"/>
    </method>
    <method name="parse" return="java.util.List&lt;com.netflix.governator.configuration.ConfigurationKeyPart&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="raw" type="java.lang.String"/>
      <param name="contextOverrides" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <doc>
      <![CDATA[Parse a key into parts

 @param raw the key
 @return parts]]>
      </doc>
    </method>
  </class>
  <!-- end class com.netflix.governator.configuration.KeyParser -->
  <!-- start class com.netflix.governator.configuration.PropertiesConfigurationProvider -->
  <class name="PropertiesConfigurationProvider" extends="com.netflix.governator.configuration.AbstractObjectConfigurationProvider"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PropertiesConfigurationProvider" type="java.util.Properties"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param properties the properties]]>
      </doc>
    </constructor>
    <constructor name="PropertiesConfigurationProvider" type="java.util.Properties, java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="PropertiesConfigurationProvider" type="java.util.Properties, java.util.Map&lt;java.lang.String, java.lang.String&gt;, ObjectMapper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setVariable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Change a variable value

 @param name  name
 @param value value]]>
      </doc>
    </method>
    <method name="has" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
    </method>
    <method name="getBooleanProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Boolean"/>
    </method>
    <method name="getIntegerProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Integer"/>
    </method>
    <method name="getLongProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Long"/>
    </method>
    <method name="getDoubleProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Double"/>
    </method>
    <method name="getStringProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.String"/>
    </method>
    <method name="getDateProperty" return="com.netflix.governator.configuration.Property&lt;java.util.Date&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.util.Date"/>
    </method>
    <doc>
    <![CDATA[ConfigurationProvider backed by a {#link Properties}]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.PropertiesConfigurationProvider -->
  <!-- start class com.netflix.governator.configuration.Property -->
  <class name="Property" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Property"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="from" return="com.netflix.governator.configuration.Property&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="T"/>
    </method>
    <method name="from" return="com.netflix.governator.configuration.Property&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="&lt;any&gt;"/>
    </method>
    <method name="from" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="com.netflix.governator.configuration.Property&lt;T&gt;"/>
    </method>
    <method name="get" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.netflix.governator.configuration.Property -->
  <!-- start class com.netflix.governator.configuration.RegexConfigurationOwnershipPolicy -->
  <class name="RegexConfigurationOwnershipPolicy" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.configuration.ConfigurationOwnershipPolicy"/>
    <constructor name="RegexConfigurationOwnershipPolicy" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="has" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="variables" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
    </method>
    <doc>
    <![CDATA[Configuration property ownership policy that checks a property against a
 regex to determine if a ConfigurationProvider owns the property.  Use this
 for dynamic configuration to give ownership in a situations where the
 configuration key may not exist in the provider at startup

 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.RegexConfigurationOwnershipPolicy -->
  <!-- start class com.netflix.governator.configuration.SystemConfigurationProvider -->
  <class name="SystemConfigurationProvider" extends="com.netflix.governator.configuration.AbstractObjectConfigurationProvider"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SystemConfigurationProvider"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SystemConfigurationProvider" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SystemConfigurationProvider" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;, ObjectMapper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setVariable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Change a variable value

 @param name  name
 @param value value]]>
      </doc>
    </method>
    <method name="has" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
    </method>
    <method name="getBooleanProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Boolean&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Boolean"/>
    </method>
    <method name="getIntegerProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Integer&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Integer"/>
    </method>
    <method name="getLongProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Long&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Long"/>
    </method>
    <method name="getDoubleProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.Double&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.Double"/>
    </method>
    <method name="getStringProperty" return="com.netflix.governator.configuration.Property&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.lang.String"/>
    </method>
    <method name="getDateProperty" return="com.netflix.governator.configuration.Property&lt;java.util.Date&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="com.netflix.governator.configuration.ConfigurationKey"/>
      <param name="defaultValue" type="java.util.Date"/>
    </method>
    <doc>
    <![CDATA[ConfigurationProvider backed by the system properties]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.configuration.SystemConfigurationProvider -->
</package>
<package name="com.netflix.governator.guice">
  <!-- start interface com.netflix.governator.guice.AutoBindProvider -->
  <interface name="AutoBindProvider"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="Binder"/>
      <param name="autoBindAnnotation" type="T extends java.lang.annotation.Annotation"/>
      <doc>
      <![CDATA[Called for auto binding of constructor arguments

 @param binder the Guice binder
 @param autoBindAnnotation the @AutoBind or custom annotation]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Used to perform the binding for a given {@link AutoBind} annotation]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.guice.AutoBindProvider -->
  <!-- start class com.netflix.governator.guice.AutoBinds -->
  <class name="AutoBinds" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="withValue" return="com.netflix.governator.annotations.AutoBind"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="value" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Used to build an {@link AutoBind} instance. Normally you won't
 use this directly.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.AutoBinds -->
  <!-- start class com.netflix.governator.guice.BootstrapBinder -->
  <class name="BootstrapBinder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="bindInterceptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classMatcher" type="&lt;any&gt;"/>
      <param name="methodMatcher" type="&lt;any&gt;"/>
      <param name="interceptors" type="MethodInterceptor[]"/>
    </method>
    <method name="bindScope"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotationType" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
      <param name="scope" type="Scope"/>
    </method>
    <method name="bindPostInjectorAction" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Bind actions to perform after the injector is created.
 
 @return a binding builder used to add a new element in the set.]]>
      </doc>
    </method>
    <method name="bindModuleTransformer" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Bind module transform operations to perform on the final list of modul.
 
 @return a binding builder used to add a new element in the set.]]>
      </doc>
    </method>
    <method name="bindLifecycleListener" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Use this to bind a {@link LifecycleListener}. It internally uses a Multibinder to do the
 binding so that you can bind multiple LifecycleListeners

 @return a binding builder used to add a new element in the set.]]>
      </doc>
    </method>
    <method name="bindResourceLocator" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Use this to bind a {@link ResourceLocator}. It internally uses a Multibinder to do the
 binding so that you can bind multiple ResourceLocators

 @return a binding builder used to add a new element in the set.]]>
      </doc>
    </method>
    <method name="bindConfigurationProvider" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Use this to bind {@link ConfigurationProvider}s. Do NOT use standard Guice binding.

 @return configuration binding builder]]>
      </doc>
    </method>
    <method name="bind" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="&lt;any&gt;"/>
    </method>
    <method name="bind" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="&lt;any&gt;"/>
    </method>
    <method name="bind" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="bindConstant" return="AnnotatedConstantBindingBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
      <param name="instance" type="T"/>
    </method>
    <method name="requestInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="instance" type="java.lang.Object"/>
    </method>
    <method name="requestStaticInjection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="types" type="java.lang.Class[]"/>
    </method>
    <method name="install"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="Module"/>
    </method>
    <method name="include"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="java.lang.Class&lt;? extends Module&gt;"/>
    </method>
    <method name="include"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Class[]"/>
    </method>
    <method name="include"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.Collection&lt;java.lang.Class&lt;? extends Module&gt;&gt;"/>
    </method>
    <method name="include"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="Module"/>
    </method>
    <method name="includeModules"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.Collection&lt;? extends Module&gt;"/>
    </method>
    <method name="includeModules"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
    </method>
    <method name="exclude"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="java.lang.Class&lt;? extends Module&gt;"/>
    </method>
    <method name="exclude"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Class[]"/>
    </method>
    <method name="exclude"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.Collection&lt;java.lang.Class&lt;? extends Module&gt;&gt;"/>
    </method>
    <method name="inStage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="Stage"/>
    </method>
    <method name="inMode"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mode" type="com.netflix.governator.guice.LifecycleInjectorMode"/>
    </method>
    <method name="currentStage" return="Stage"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="arguments" type="java.lang.Object[]"/>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="addError"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="message" type="Message"/>
    </method>
    <method name="getProvider" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="&lt;any&gt;"/>
    </method>
    <method name="getProvider" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="getMembersInjector" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeLiteral" type="&lt;any&gt;"/>
    </method>
    <method name="getMembersInjector" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="convertToTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeMatcher" type="&lt;any&gt;"/>
      <param name="converter" type="TypeConverter"/>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="typeMatcher" type="&lt;any&gt;"/>
      <param name="listener" type="TypeListener"/>
    </method>
    <method name="withSource" return="Binder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="source" type="java.lang.Object"/>
    </method>
    <method name="skipSources" return="Binder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classesToSkip" type="java.lang.Class[]"/>
    </method>
    <method name="newPrivateBinder" return="PrivateBinder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="requireExplicitBindings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="disableCircularProxies"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="disableAutoBinding"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getProvider" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dependency" type="&lt;any&gt;"/>
    </method>
    <method name="bindListener"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bindingMatcher" type="&lt;any&gt;"/>
      <param name="listeners" type="ProvisionListener[]"/>
    </method>
    <method name="requireAtInjectOnConstructors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="requireExactBindingAnnotations"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="scanModulesForAnnotatedMethods"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scanner" type="ModuleAnnotatedMethodScanner"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.BootstrapBinder -->
  <!-- start interface com.netflix.governator.guice.BootstrapModule -->
  <interface name="BootstrapModule"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.netflix.governator.guice.BootstrapBinder"/>
      <doc>
      <![CDATA[Called to allow for binding

 @param binder the bootstrap binder]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstraction for binding during the bootstrap phase]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.guice.BootstrapModule -->
  <!-- start class com.netflix.governator.guice.DelegatingLifecycleInjectorBuilder -->
  <class name="DelegatingLifecycleInjectorBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.LifecycleInjectorBuilder"/>
    <constructor name="DelegatingLifecycleInjectorBuilder" type="com.netflix.governator.guice.LifecycleInjectorBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="withBootstrapModule" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="com.netflix.governator.guice.BootstrapModule"/>
    </method>
    <method name="withAdditionalBootstrapModules" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.netflix.governator.guice.BootstrapModule[]"/>
    </method>
    <method name="withAdditionalBootstrapModules" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.netflix.governator.guice.BootstrapModule&gt;"/>
    </method>
    <method name="withModules" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
    </method>
    <method name="withModules" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends Module&gt;"/>
    </method>
    <method name="withAdditionalModules" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends Module&gt;"/>
    </method>
    <method name="withAdditionalModules" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
    </method>
    <method name="withRootModule" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mainModule" type="java.lang.Class&lt;?&gt;"/>
    </method>
    <method name="withModuleClass" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="java.lang.Class&lt;? extends Module&gt;"/>
    </method>
    <method name="withModuleClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;java.lang.Class&lt;? extends Module&gt;&gt;"/>
    </method>
    <method name="withModuleClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Class[]"/>
    </method>
    <method name="withAdditionalModuleClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;java.lang.Class&lt;? extends Module&gt;&gt;"/>
    </method>
    <method name="withAdditionalModuleClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Class[]"/>
    </method>
    <method name="ignoringAutoBindClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignoreClasses" type="java.util.Collection&lt;java.lang.Class&lt;?&gt;&gt;"/>
    </method>
    <method name="ignoringAllAutoBindClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="usingBasePackages" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="basePackages" type="java.lang.String[]"/>
    </method>
    <method name="usingBasePackages" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="basePackages" type="java.util.Collection&lt;java.lang.String&gt;"/>
    </method>
    <method name="usingClasspathScanner" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scanner" type="com.netflix.governator.lifecycle.ClasspathScanner"/>
    </method>
    <method name="inStage" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="Stage"/>
    </method>
    <method name="withMode" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mode" type="com.netflix.governator.guice.LifecycleInjectorMode"/>
    </method>
    <method name="withModuleTransformer" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transformer" type="com.netflix.governator.guice.ModuleTransformer"/>
    </method>
    <method name="withModuleTransformer" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transformers" type="java.util.Collection&lt;? extends com.netflix.governator.guice.ModuleTransformer&gt;"/>
    </method>
    <method name="withModuleTransformer" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transformers" type="com.netflix.governator.guice.ModuleTransformer[]"/>
    </method>
    <method name="withPostInjectorAction" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="com.netflix.governator.guice.PostInjectorAction"/>
    </method>
    <method name="withPostInjectorActions" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="actions" type="java.util.Collection&lt;? extends com.netflix.governator.guice.PostInjectorAction&gt;"/>
    </method>
    <method name="withPostInjectorActions" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="actions" type="com.netflix.governator.guice.PostInjectorAction[]"/>
    </method>
    <method name="withoutModuleClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;java.lang.Class&lt;? extends Module&gt;&gt;"/>
    </method>
    <method name="withoutModuleClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Class[]"/>
    </method>
    <method name="withoutModuleClass" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="java.lang.Class&lt;? extends Module&gt;"/>
    </method>
    <method name="build" return="com.netflix.governator.guice.LifecycleInjector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="createInjector" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Decorator for LifecycleInjectorBuilder which makes the original withModules methods 
 additive instead of replacing any pre-defined module.  This class also acts as a default
 implementation for overriding the behavior of LifecycleInjectorBuilder so that code
 does not break every time a new method is added.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.DelegatingLifecycleInjectorBuilder -->
  <!-- start class com.netflix.governator.guice.Grapher -->
  <class name="Grapher" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Grapher" type="Injector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new Grapher.

 @param injector the Injector whose dependency graph will be generated]]>
      </doc>
    </constructor>
    <constructor name="Grapher" type="Injector, &lt;any&gt;[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new Grapher.

 @param injector the Injector whose dependency graph will be generated
 @param keys {@code Key}s for the roots of the graph]]>
      </doc>
    </constructor>
    <constructor name="Grapher" type="Injector, java.lang.Class[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new Grapher.

 @param injector the Injector whose dependency graph will be generated
 @param classes {@code Class}es for the roots of the graph]]>
      </doc>
    </constructor>
    <constructor name="Grapher" type="Injector, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new Grapher.

 @param injector the Injector whose dependency graph will be generated
 @param packages names of {@code Package}s for the roots of the graph]]>
      </doc>
    </constructor>
    <method name="toFile" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Writes the "Dot" graph to a new temp file.

 @return the name of the newly created file]]>
      </doc>
    </method>
    <method name="toFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Writes the "Dot" graph to a given file.

 @param file file to write to]]>
      </doc>
    </method>
    <method name="graph" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Returns a String containing the "Dot" graph definition.

 @return the "Dot" graph definition]]>
      </doc>
    </method>
    <doc>
    <![CDATA[An object that can generate a graph showing a Guice Dependency Injection graph.

 @see <a href="http://www.graphviz.org/">GraphViz</a>
 @see <a href="http://code.google.com/p/google-guice/wiki/Grapher">Guice Grapher</a>
 @see <a href="http://code.google.com/p/jrfonseca/wiki/XDot">XDot, an interactive viewer for Dot files</a>]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.Grapher -->
  <!-- start class com.netflix.governator.guice.InternalAutoBindModuleBootstrapModule -->
  <class name="InternalAutoBindModuleBootstrapModule" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.BootstrapModule"/>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.netflix.governator.guice.BootstrapBinder"/>
    </method>
    <doc>
    <![CDATA[Custom BootstrapModule that auto-installs guice modules annotated with AutoBindSingleton
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.InternalAutoBindModuleBootstrapModule -->
  <!-- start class com.netflix.governator.guice.LifecycleInjector -->
  <class name="LifecycleInjector" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="builder" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create a new LifecycleInjector builder

 @return builder]]>
      </doc>
    </method>
    <method name="bootstrap" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="main" type="java.lang.Class&lt;?&gt;"/>
    </method>
    <method name="bootstrap" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="main" type="java.lang.Class&lt;?&gt;"/>
      <param name="externalBootstrapModules" type="com.netflix.governator.guice.BootstrapModule[]"/>
    </method>
    <method name="bootstrap" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="main" type="java.lang.Class&lt;?&gt;"/>
      <param name="externalBindings" type="Module"/>
      <param name="externalBootstrapModules" type="com.netflix.governator.guice.BootstrapModule[]"/>
      <doc>
      <![CDATA[This is a shortcut to configuring the LifecycleInjectorBuilder using annotations.
 
 Using bootstrap a main application class can simply be annotated with 
 custom annotations that are mapped to {@link BootstrapModule}s.
 Each annotations can then map to a subsystem or feature that is enabled on 
 the main application class.  {@link BootstrapModule}s are installed in the order in which 
 they are defined.
 
 @see {@link Bootstrap}
 @param main Main application bootstrap class
 @param externalBindings Bindings that are provided externally by the caller to bootstrap.  These
        bindings are injectable into the BootstrapModule instances
 @param externalBootstrapModules Optional modules that are processed after all the main class bootstrap modules
 @return The created injector]]>
      </doc>
    </method>
    <method name="createStandardClasspathScanner" return="com.netflix.governator.lifecycle.ClasspathScanner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="basePackages" type="java.util.Collection&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[If you need early access to the CLASSPATH scanner. For performance reasons, you should
 pass the scanner to the builder via {@link LifecycleInjectorBuilder#usingClasspathScanner(ClasspathScanner)}.

 @param basePackages packages to recursively scan
 @return scanner]]>
      </doc>
    </method>
    <method name="createStandardClasspathScanner" return="com.netflix.governator.lifecycle.ClasspathScanner"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="basePackages" type="java.util.Collection&lt;java.lang.String&gt;"/>
      <param name="additionalAnnotations" type="java.util.List&lt;java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;&gt;"/>
      <doc>
      <![CDATA[If you need early access to the CLASSPATH scanner. For performance reasons, you should
 pass the scanner to the builder via {@link LifecycleInjectorBuilder#usingClasspathScanner(ClasspathScanner)}.

 @param basePackages packages to recursively scan
 @param additionalAnnotations any additional annotations to scan for
 @return scanner]]>
      </doc>
    </method>
    <method name="getLifecycleManager" return="com.netflix.governator.lifecycle.LifecycleManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the internally created lifecycle manager

 @return manager]]>
      </doc>
    </method>
    <method name="createChildInjector" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
      <doc>
      <![CDATA[Create an injector that is a child of the bootstrap bindings only

 @param modules binding modules
 @return injector]]>
      </doc>
    </method>
    <method name="createChildInjector" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.Collection&lt;Module&gt;"/>
      <doc>
      <![CDATA[Create an injector that is a child of the bootstrap bindings only

 @param modules binding modules
 @return injector]]>
      </doc>
    </method>
    <method name="createInjector" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create the main injector

 @return injector]]>
      </doc>
    </method>
    <method name="createInjector" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
      <doc>
      <![CDATA[Create the main injector

 @param modules any additional modules
 @return injector]]>
      </doc>
    </method>
    <method name="createInjector" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="additionalModules" type="java.util.Collection&lt;Module&gt;"/>
      <doc>
      <![CDATA[Create the main injector

 @param additionalModules any additional modules
 @return injector]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
     When using Governator, do NOT create a Guice injector manually. Instead, use a LifecycleInjector to create a Guice injector.
 </p>

 <p>
     Governator uses a two pass binding. The bootstrap binding injects:
     <li>{@link LifecycleManager}</li>
     <li>Any application defined bootstrap instances</li>
     <br/>
     The main binding injects everything else.
 </p>

 <p>
     The bootstrap binding occurs when the LifecycleInjector is created. The main binding
     occurs when {@link #createInjector()} is called.
 </p>]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.LifecycleInjector -->
  <!-- start interface com.netflix.governator.guice.LifecycleInjectorBuilder -->
  <interface name="LifecycleInjectorBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="withBootstrapModule" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="com.netflix.governator.guice.BootstrapModule"/>
      <doc>
      <![CDATA[Specify a bootstrap module

 @param module the module
 @return this]]>
      </doc>
    </method>
    <method name="withAdditionalBootstrapModules" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="com.netflix.governator.guice.BootstrapModule[]"/>
      <doc>
      <![CDATA[Specify additional bootstrap modules to use

 @param modules modules
 @return this]]>
      </doc>
    </method>
    <method name="withAdditionalBootstrapModules" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends com.netflix.governator.guice.BootstrapModule&gt;"/>
      <doc>
      <![CDATA[Specify additional bootstrap modules to use

 @param modules modules
 @return this]]>
      </doc>
    </method>
    <method name="withModules" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
      <doc>
      <![CDATA[Specify standard Guice modules for the main binding phase.  Note that any
 modules provided in a previous call to withModules will be discarded.
 To add to the list of modules call {@link #withAdditionalModules}

 @param modules modules
 @return this]]>
      </doc>
    </method>
    <method name="withModules" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends Module&gt;"/>
      <doc>
      <![CDATA[Specify standard Guice modules for the main binding phase. Note that any
 modules provided in a previous call to withModules will be discarded.
 To add to the list of modules call {@link #withAdditionalModules}

 @param modules modules
 @return this]]>
      </doc>
    </method>
    <method name="withAdditionalModules" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends Module&gt;"/>
      <doc>
      <![CDATA[Add to any modules already specified via {@link #withModules(Iterable)}

 @param modules modules
 @return this]]>
      </doc>
    </method>
    <method name="withAdditionalModules" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
      <doc>
      <![CDATA[Add to any modules already specified via {@link #withModules(Iterable)}

 @param modules modules
 @return this]]>
      </doc>
    </method>
    <method name="withRootModule" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mainModule" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Specify a root application module class from which a set of additional modules
 may be derived using module dependencies. Module dependencies are specified
 using @Inject on the module constructor and indicating the dependent modules
 as constructor arguments.

 @param mainModule root application module
 @return this]]>
      </doc>
    </method>
    <method name="withModuleClass" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="java.lang.Class&lt;? extends Module&gt;"/>
      <doc>
      <![CDATA[Specify a module class from which a set of additional modules may be derived
 using module dependencies. Module dependencies are specified
 using @Inject on the module constructor and indicating the dependent modules
 as constructor arguments.

 @param module root application module
 @return this]]>
      </doc>
    </method>
    <method name="withModuleClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;java.lang.Class&lt;? extends Module&gt;&gt;"/>
      <doc>
      <![CDATA[Specify a set of module classes from which a set of additional modules may be derived
 using module dependencies. Module dependencies are specified
 using @Inject on the module constructor and indicating the dependent modules
 as constructor arguments.

 Note that any existing modules that were added will be removed by this call

 @param modules root application modules
 @return this]]>
      </doc>
    </method>
    <method name="withModuleClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Specify a set of module classes from which a set of additional modules may be derived
 using module dependencies. Module dependencies are specified
 using @Inject on the module constructor and indicating the dependent modules
 as constructor arguments.

 Note that any existing modules that were added will be removed by this call

 @param modules root application modules
 @return this]]>
      </doc>
    </method>
    <method name="withAdditionalModuleClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;java.lang.Class&lt;? extends Module&gt;&gt;"/>
      <doc>
      <![CDATA[Specify a set of module classes from which a set of additional modules may be derived
 using module dependencies. Module dependencies are specified
 using @Inject on the module constructor and indicating the dependent modules
 as constructor arguments.

 Note that any existing modules that were added will be removed by this call
 @param modules root application modules
 @return this]]>
      </doc>
    </method>
    <method name="withAdditionalModuleClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Specify a set of module classes from which a set of additional modules may be derived
 using module dependencies. Module dependencies are specified
 using @Inject on the module constructor and indicating the dependent modules
 as constructor arguments.

 @param modules root application modules
 @return this]]>
      </doc>
    </method>
    <method name="withoutModuleClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;java.lang.Class&lt;? extends Module&gt;&gt;"/>
      <doc>
      <![CDATA[When using module dependencies ignore the specified classes
 
 @param modules to exclude
 @return this]]>
      </doc>
    </method>
    <method name="withoutModuleClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[When using module dependencies ignore the specified classes
 @param modules to exclude
 @return this]]>
      </doc>
    </method>
    <method name="withoutModuleClass" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="java.lang.Class&lt;? extends Module&gt;"/>
      <doc>
      <![CDATA[When using module dependencies ignore the specified class
 @param module to exclude
 @return this]]>
      </doc>
    </method>
    <method name="ignoringAutoBindClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="ignoreClasses" type="java.util.Collection&lt;java.lang.Class&lt;?&gt;&gt;"/>
      <doc>
      <![CDATA[Specify specific {@link AutoBindSingleton} classes that should NOT be bound in the main
 binding phase

 @param ignoreClasses classes to not bind
 @return this]]>
      </doc>
    </method>
    <method name="ignoringAllAutoBindClasses" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Do not bind ANY {@link AutoBindSingleton} classes

 @return this]]>
      </doc>
    </method>
    <method name="usingBasePackages" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="basePackages" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Specify the base packages for CLASSPATH scanning. Packages are recursively scanned

 @param basePackages packages
 @return this]]>
      </doc>
    </method>
    <method name="usingBasePackages" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="basePackages" type="java.util.Collection&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[Specify the base packages for CLASSPATH scanning. Packages are recursively scanned

 @param basePackages packages
 @return this]]>
      </doc>
    </method>
    <method name="usingClasspathScanner" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="scanner" type="com.netflix.governator.lifecycle.ClasspathScanner"/>
      <doc>
      <![CDATA[Normally, the classpath scanner is allocated internally. This method allows for a custom
 scanner to be used. NOTE: Any packages specifies via {@link #usingBasePackages(String...)} will
 be ignored if this method is called.

 @param scanner the scanner to use
 @return this]]>
      </doc>
    </method>
    <method name="inStage" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="Stage"/>
      <doc>
      <![CDATA[Set the Guice stage - the default is Production

 @param stage new stage
 @return this]]>
      </doc>
    </method>
    <method name="withMode" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mode" type="com.netflix.governator.guice.LifecycleInjectorMode"/>
      <doc>
      <![CDATA[Set the lifecycle injector mode - default is {@link LifecycleInjectorMode#REAL_CHILD_INJECTORS}

 @param mode new mode
 @return this]]>
      </doc>
    </method>
    <method name="withModuleTransformer" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transformer" type="com.netflix.governator.guice.ModuleTransformer"/>
      <doc>
      <![CDATA[Just before creating the injector all the modules will run through the transformer.
 Transformers will be executed in the order in which withModuleTransformer
 is called.  Note that once the first filter is called subsequent calls will only be
 given the previous set of filtered modules.

 @param transformer
 @return this]]>
      </doc>
    </method>
    <method name="withModuleTransformer" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transformer" type="java.util.Collection&lt;? extends com.netflix.governator.guice.ModuleTransformer&gt;"/>
      <doc>
      <![CDATA[Just before creating the injector all the modules will run through the filter.
 Transformers will be executed in the order in which withModuleTransformer
 is called.  Note that once the first filter is called subsequent calls will only be
 given the previous set of filtered modules.

 @param transformer
 @return this]]>
      </doc>
    </method>
    <method name="withModuleTransformer" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="transformer" type="com.netflix.governator.guice.ModuleTransformer[]"/>
      <doc>
      <![CDATA[Just before creating the injector all the modules will run through the filter.
 Transformers will be executed in the order in which withModuleTransformer
 is called.  Note that once the first filter is called subsequent calls will only be
 given the previous set of filtered modules.

 @param transformer
 @return this]]>
      </doc>
    </method>
    <method name="withPostInjectorAction" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="com.netflix.governator.guice.PostInjectorAction"/>
      <doc>
      <![CDATA[Action to perform after the injector is created.  Note that post injection actions
 are performed in the same order as calls to withPostInjectorAction
 @param action
 @return]]>
      </doc>
    </method>
    <method name="withPostInjectorActions" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="action" type="java.util.Collection&lt;? extends com.netflix.governator.guice.PostInjectorAction&gt;"/>
      <doc>
      <![CDATA[Actions to perform after the injector is created.  Note that post injection actions
 are performed in the same order as calls to withPostInjectorAction
 @param action
 @return]]>
      </doc>
    </method>
    <method name="withPostInjectorActions" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="actions" type="com.netflix.governator.guice.PostInjectorAction[]"/>
      <doc>
      <![CDATA[Actions to perform after the injector is created.  Note that post injection actions
 are performed in the same order as calls to withPostInjectorAction
 @param action
 @return]]>
      </doc>
    </method>
    <method name="build" return="com.netflix.governator.guice.LifecycleInjector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Build and return the injector

 @return LifecycleInjector]]>
      </doc>
    </method>
    <method name="createInjector" return="Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="this API creates the quote_cHaRmainquote_cHaR child injector.
 but it has the side effect of calling build() method
 that will create a new LifecycleInjector.
 Instead, you should just build() LifecycleInjector object.
 then call LifecycleInjector.createInjector() directly.">
      <doc>
      <![CDATA[Internally build the LifecycleInjector and then return the result of calling
 {@link LifecycleInjector#createInjector()}

 @return Guice injector

 @deprecated this API creates the "main" child injector.
 but it has the side effect of calling build() method
 that will create a new LifecycleInjector.
 Instead, you should just build() LifecycleInjector object.
 then call LifecycleInjector.createInjector() directly.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Builder for a {@link LifecycleInjector}]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.guice.LifecycleInjectorBuilder -->
  <!-- start interface com.netflix.governator.guice.LifecycleInjectorBuilderSuite -->
  <interface name="LifecycleInjectorBuilderSuite"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="This class is deprecated in favor of using {@link BootstrapModule} or just {@link ModuleInfo}.  All the 
 {@link LifecycleInjectorBuilder} functionality is now available via the {@link BootstrapBinder}
 passed to {@link BootstrapModule}">
    <method name="configure"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="com.netflix.governator.guice.LifecycleInjectorBuilder"/>
      <doc>
      <![CDATA[Override this to perform any combination of operations on the
 LifecycleInjectorBuilder
 
 @param builder]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Each concrete LifecycleInjectorSuite represent a specific set operations
 on a LifecycleInjectorBuilder that should logically be grouped together.
 Multiple suites can then be applied to the LifecycleInjectorBuilder.
 
 @author elandau
 
 @deprecated This class is deprecated in favor of using {@link BootstrapModule} or just {@link ModuleInfo}.  All the 
 {@link LifecycleInjectorBuilder} functionality is now available via the {@link BootstrapBinder}
 passed to {@link BootstrapModule}]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.guice.LifecycleInjectorBuilderSuite -->
  <!-- start class com.netflix.governator.guice.LifecycleInjectorMode -->
  <class name="LifecycleInjectorMode" extends="java.lang.Enum&lt;com.netflix.governator.guice.LifecycleInjectorMode&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.netflix.governator.guice.LifecycleInjectorMode[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.netflix.governator.guice.LifecycleInjectorMode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.LifecycleInjectorMode -->
  <!-- start class com.netflix.governator.guice.LifecycleTester -->
  <class name="LifecycleTester" extends="ExternalResource"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LifecycleTester" type="java.util.List&lt;com.netflix.governator.guice.BootstrapModule&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifecycleTester" type="com.netflix.governator.guice.BootstrapModule[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifecycleTester" type="java.lang.Class, com.netflix.governator.guice.BootstrapModule[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="start" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the new Injector]]>
      </doc>
    </method>
    <method name="withBootstrapModule" return="com.netflix.governator.guice.LifecycleTester"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bootstrapModule" type="com.netflix.governator.guice.BootstrapModule"/>
    </method>
    <method name="withExternalBindings" return="com.netflix.governator.guice.LifecycleTester"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="Module"/>
    </method>
    <method name="builder" return="com.netflix.governator.guice.LifecycleInjectorBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
    </method>
    <method name="getInstance" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
    </method>
    <method name="after"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override to tear down your specific external resource.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Rule for testing with governator.  The rule provides the following conveniences
 1.  Mechanism to customize the configuration via external modules.
 2.  Auto shutdown the lifecycle manager when a test ends
 3.  Methods to test whether certain bindings were heard and injected

 Usage

 <pre>
 public class MyUnitTest {
     &#64;Rule
     public LifecycleTester tester = new LifecycleTester(new MyTestSuite());

     &#64;Test
     public void test() {
         // Test specific setup
         tester.builder().
             withAdditionalModule(new TheModuleImTesting());

         // Creates the injector and start LifecycleManager
         tester.start();

         // Your test code goes here

     } // On termination the LifecycleTester will shutdown LifecycleManager
 }

 </pre>

 public static class
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.LifecycleTester -->
  <!-- start class com.netflix.governator.guice.LoadersBootstrapModule -->
  <class name="LoadersBootstrapModule" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.BootstrapModule"/>
    <constructor name="LoadersBootstrapModule" type="com.netflix.governator.lifecycle.ClasspathScanner"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.netflix.governator.guice.BootstrapBinder"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.LoadersBootstrapModule -->
  <!-- start class com.netflix.governator.guice.ModuleListBuilder -->
  <class name="ModuleListBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ModuleListBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="includeModules" return="com.netflix.governator.guice.ModuleListBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;? extends Module&gt;"/>
    </method>
    <method name="include" return="com.netflix.governator.guice.ModuleListBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;java.lang.Class&lt;? extends Module&gt;&gt;"/>
    </method>
    <method name="include" return="com.netflix.governator.guice.ModuleListBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="Module"/>
    </method>
    <method name="exclude" return="com.netflix.governator.guice.ModuleListBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="m" type="java.lang.Class&lt;? extends Module&gt;"/>
    </method>
    <method name="exclude" return="com.netflix.governator.guice.ModuleListBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.lang.Iterable&lt;java.lang.Class&lt;? extends Module&gt;&gt;"/>
    </method>
    <doc>
    <![CDATA[The {@link ModuleListBuilder} keeps track of modules and their transitive dependencies
 and provides a mechanism to replace or exclude modules. 
 
 When {@link build()} is called a list of modules is created and modules will be ordered
 in the order in which they were added while allowing for dependent modules to be listed
 first.
 
 TODO: Provide exclude source
 TODO: Provide include source
 TODO: Force include
 TODO: Guard against circular dependencies
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.ModuleListBuilder -->
  <!-- start class com.netflix.governator.guice.ModuleListBuilder.ModuleProvider -->
  <class name="ModuleListBuilder.ModuleProvider" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ModuleProvider" type="java.lang.Class&lt;? extends Module&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ModuleProvider" type="Module"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setInstance"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="Module"/>
    </method>
    <method name="getInstance" return="Module"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="Injector"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <doc>
    <![CDATA[Internal class to track either a module class or instance
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.ModuleListBuilder.ModuleProvider -->
  <!-- start class com.netflix.governator.guice.ModulesEx -->
  <class name="ModulesEx" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ModulesEx"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="combineAndOverride" return="Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="Module[]"/>
    </method>
    <method name="combineAndOverride" return="Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.List&lt;? extends Module&gt;"/>
      <doc>
      <![CDATA[Generate a single module that is produced by accumulating and overriding
 each module with the next.
 
 <pre>
 {@code 
 Guice.createInjector(ModuleUtils.combineAndOverride(moduleA, moduleAOverrides, moduleB));
 }
 </pre>
 
 @param modules
 @return]]>
      </doc>
    </method>
    <method name="fromClass" return="Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cls" type="java.lang.Class&lt;?&gt;"/>
    </method>
    <method name="fromClass" return="Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cls" type="java.lang.Class&lt;?&gt;"/>
      <param name="override" type="boolean"/>
      <doc>
      <![CDATA[Create a single module that derived from all bootstrap annotations
 on a class, where that class itself is a module.
 
 For example,
 <pre>
 {@code 
    public class MainApplicationModule extends AbstractModule {
        @Override
        public void configure() {
            // Application specific bindings here
        }
        
        public static void main(String[] args) {
            Guice.createInjector(ModulesEx.fromClass(MainApplicationModule.class));
        }
    }
 }
 </pre>
 @author elandau]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility class similar to Guice's Modules that simplifies recipes for
 combing Guice modules.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.ModulesEx -->
  <!-- start interface com.netflix.governator.guice.ModuleTransformer -->
  <interface name="ModuleTransformer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="call" return="java.util.Collection&lt;Module&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.Collection&lt;Module&gt;"/>
    </method>
    <doc>
    <![CDATA[Before creating the injector the modules are passed through a collection
 of filters that can filter out or modify bindings
 
 @author elandau]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.guice.ModuleTransformer -->
  <!-- start interface com.netflix.governator.guice.PostInjectorAction -->
  <interface name="PostInjectorAction"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="call"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="Injector"/>
    </method>
    <doc>
    <![CDATA[Action to perform after the injector is created.
 
 @author elandau]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.guice.PostInjectorAction -->
  <!-- start class com.netflix.governator.guice.SingletonModule -->
  <class name="SingletonModule" extends="com.netflix.governator.SingletonModule"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="Use com.netflix.governator.SingletonModule instead">
    <constructor name="SingletonModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Base module that ensures only one module is used when multiple modules
 are installed using the concrete module class as the dedup key.  To 
 ensure 'best practices' this class also forces the concrete module to
 be final.  This is done to prevent the use of inheritance for overriding
 behavior in favor of using Modules.override().
 
 @author elandau

 @deprecated Use com.netflix.governator.SingletonModule instead]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.SingletonModule -->
</package>
<package name="com.netflix.governator.guice.actions">
  <!-- start class com.netflix.governator.guice.actions.BindingReport -->
  <class name="BindingReport" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.PostInjectorAction"/>
    <constructor name="BindingReport" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BindingReport"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="call"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="Injector"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.actions.BindingReport -->
  <!-- start class com.netflix.governator.guice.actions.CreateAllBoundSingletons -->
  <class name="CreateAllBoundSingletons" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.PostInjectorAction"/>
    <constructor name="CreateAllBoundSingletons"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="call"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="Injector"/>
    </method>
    <doc>
    <![CDATA[Explicit singleton bindings are not eagerly created when running in Stage.DEVELOPMENT.
 This method iterates through all explicit bindings (those made though a guice module) for singletons
 and creates them eagerly after the injector was created.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.actions.CreateAllBoundSingletons -->
  <!-- start class com.netflix.governator.guice.actions.GrapherAction -->
  <class name="GrapherAction" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.PostInjectorAction"/>
    <constructor name="GrapherAction"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="call"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="Injector"/>
    </method>
    <method name="getText" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.actions.GrapherAction -->
  <!-- start class com.netflix.governator.guice.actions.LifecycleManagerStarter -->
  <class name="LifecycleManagerStarter" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.PostInjectorAction"/>
    <constructor name="LifecycleManagerStarter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="call"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="injector" type="Injector"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.actions.LifecycleManagerStarter -->
</package>
<package name="com.netflix.governator.guice.annotations">
  <!-- start class com.netflix.governator.guice.annotations.Bootstrap -->
  <class name="Bootstrap"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
  </class>
  <!-- end class com.netflix.governator.guice.annotations.Bootstrap -->
  <!-- start class com.netflix.governator.guice.annotations.Bootstrap.NullBootstrapModule -->
  <class name="Bootstrap.NullBootstrapModule" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.BootstrapModule"/>
    <constructor name="NullBootstrapModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.netflix.governator.guice.BootstrapBinder"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.annotations.Bootstrap.NullBootstrapModule -->
  <!-- start class com.netflix.governator.guice.annotations.Bootstrap.NullLifecycleInjectorBuilderSuite -->
  <class name="Bootstrap.NullLifecycleInjectorBuilderSuite" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.LifecycleInjectorBuilderSuite"/>
    <constructor name="NullLifecycleInjectorBuilderSuite"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builder" type="com.netflix.governator.guice.LifecycleInjectorBuilder"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.annotations.Bootstrap.NullLifecycleInjectorBuilderSuite -->
  <!-- start class com.netflix.governator.guice.annotations.Bootstrap.NullModule -->
  <class name="Bootstrap.NullModule" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="NullModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="Binder"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.annotations.Bootstrap.NullModule -->
  <!-- start class com.netflix.governator.guice.annotations.GovernatorConfiguration -->
  <class name="GovernatorConfiguration"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Governator configuration for the main bootstrap class with 'good' default]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.annotations.GovernatorConfiguration -->
</package>
<package name="com.netflix.governator.guice.bootstrap">
  <!-- start class com.netflix.governator.guice.bootstrap.GovernatorBootstrap -->
  <class name="GovernatorBootstrap" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.BootstrapModule"/>
    <constructor name="GovernatorBootstrap" type="com.netflix.governator.guice.annotations.GovernatorConfiguration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.netflix.governator.guice.BootstrapBinder"/>
    </method>
    <doc>
    <![CDATA[Implementation for the @GovernatorConfiguration main bootstrap class annotation]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.bootstrap.GovernatorBootstrap -->
  <!-- start class com.netflix.governator.guice.bootstrap.ModulesBootstrap -->
  <class name="ModulesBootstrap" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.BootstrapModule"/>
    <constructor name="ModulesBootstrap" type="com.netflix.governator.annotations.Modules"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.netflix.governator.guice.BootstrapBinder"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.bootstrap.ModulesBootstrap -->
</package>
<package name="com.netflix.governator.guice.concurrent">
  <!-- start class com.netflix.governator.guice.concurrent.ConcurrentProviders -->
  <class name="ConcurrentProviders" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConcurrentProviders"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="of" return="&lt;any&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;? extends T&gt;"/>
      <doc>
      <![CDATA[Create a Provider that will construct all constructor arguments in parallel and wait
 for all dependencies to be constructed before invoking the constructor of the type.
 
 For example, consider the following class that has 4 dependencies
 
 {@code 
 @Singleton
 public class Foo {
     @Inject
     public Foo(@NonConcurrent NonConcurrentSingleton, DependencyA a, DependencyB b, Provider<DependencyC> c, NonSingletonD d) {
     }
 }
 }
 
 and the following Guice binding to enable the concurrent behavior,
 
 {@code
 public configure() {
     bind(Foo.class).toProvider(ConcurrentProviders.of(Foo.class)).asEagerSingleton();
 }
 }
 
 When Foo is created eagerly (by Guice) the provider will spawn 4 threads each creating
 one of the above dependencies.  Note that for Provider<DependencyC> the provider will 
 be created and not an instance of DependencyC.  Also, note that NonConcurrentSingleton
 will not be constructed in a separate thread.
 
 Note that a dedicated pool of N threads (where N is the number of dependencies) is created
 when Foo is first constructed.  Upon instantiation of Foo the pool is shut down and the 
 resulting instance of Foo cached for future retrieval.  
 
 It's also important to note that ALL transitive dependencies of Foo MUST be in the
 <b>FineGrainedLazySingleton</b> scope, otherwise there is a high risk of hitting the global Guice
 Singleton scope deadlock issue.  Any parameter that causes this deadlock can be annotated 
 with @NonConcurrent to force it to be created within the same thread as the injectee.
 
 @param type
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Utility class for creating Providers that allow for concurrent instantiation
 of dependencies to a type.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.concurrent.ConcurrentProviders -->
</package>
<package name="com.netflix.governator.guice.jetty">
  <!-- start class com.netflix.governator.guice.jetty.DefaultJettyConfig -->
  <class name="DefaultJettyConfig" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.jetty.JettyConfig"/>
    <constructor name="DefaultJettyConfig"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPort" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setPort" return="com.netflix.governator.guice.jetty.DefaultJettyConfig"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="port" type="int"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.jetty.DefaultJettyConfig -->
  <!-- start interface com.netflix.governator.guice.jetty.JettyConfig -->
  <interface name="JettyConfig"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getPort" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </interface>
  <!-- end interface com.netflix.governator.guice.jetty.JettyConfig -->
  <!-- start class com.netflix.governator.guice.jetty.JettyLifecycleShutdownSignal -->
  <class name="JettyLifecycleShutdownSignal" extends="com.netflix.governator.AbstractLifecycleShutdownSignal"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JettyLifecycleShutdownSignal" type="Server, com.netflix.governator.LifecycleManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="signal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="await"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.jetty.JettyLifecycleShutdownSignal -->
  <!-- start class com.netflix.governator.guice.jetty.JettyModule -->
  <class name="JettyModule" extends="AbstractModule"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="JettyModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Installing JettyModule will create a Jetty web server within the context
 of the Injector and will use servlet and filter bindings from any additionally
 installed ServletModule.
 
 
 <pre>
 {@code
    public static void main(String args[]) throws Exception {
        Governator.createInjector(
                new SampleServletModule(), 
                new ShutdownHookModule(), 
                new JettyModule())
                .awaitTermination();
    }
 }
 
 To change Jetty's configuration provide an override binding for JettyConfig.class.
 
 <pre>
 {@code 
    public static void main(String args[]) throws Exception {
        Governator.createInjector(
                new SampleServletModule(), 
                new ShutdownHookModule(), 
                Modules.override(new JettyModule())
                       .with(new AbstractModule() {
                           @Overrides
                           private void configure() {}
                           
                           @Provider
                           @Singleton 
                           private JettyConfig getConfig() {
                               DefaultJettyConfig config = new DefaultJettyConfig();
                               config.setPort(80);
                               return config;
                           }
                       })
                .awaitTermination());
    }
 }
 </pre>
 
 Note that only one Jetty server may be created in an Injector 
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.jetty.JettyModule -->
  <!-- start class com.netflix.governator.guice.jetty.JettyModule.JettyRunner -->
  <class name="JettyModule.JettyRunner" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JettyRunner" type="Server, com.netflix.governator.LifecycleManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Eager singleton to start the Jetty Server
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.jetty.JettyModule.JettyRunner -->
  <!-- start class com.netflix.governator.guice.jetty.JettyModule.JettyShutdown -->
  <class name="JettyModule.JettyShutdown" extends="com.netflix.governator.AbstractLifecycleListener"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JettyShutdown" type="Server"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="onStopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="optionalError" type="java.lang.Throwable"/>
    </method>
    <doc>
    <![CDATA[LifecycleListener to stop Jetty Server.  This will catch shutting down 
 Jetty when notified only through LifecycleManager#shutdown() and not via the 
 LifecycleEvent#shutdown().
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.jetty.JettyModule.JettyShutdown -->
</package>
<package name="com.netflix.governator.guice.lazy">
  <!-- start class com.netflix.governator.guice.lazy.FineGrainedLazySingleton -->
  <class name="FineGrainedLazySingleton"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="Use javax.inject.Singleton instead.  FineGrainedLazySingleton is not needed 
 as of Guice4 which fixes the global lock issue.">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Same as {@link LazySingleton} with the addition of allowing for more
 concurrency. The various {@link Scopes#SINGLETON} based scopes have
 a major concurrency restriction due to a blunt synchronization (see
 the comment inside of the Guice code). This version synchronizes
 on the object key and, thus, can construct multiple types of singletons
 concurrently.
 
 @deprecated Use javax.inject.Singleton instead.  FineGrainedLazySingleton is not needed 
 as of Guice4 which fixes the global lock issue.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.lazy.FineGrainedLazySingleton -->
  <!-- start class com.netflix.governator.guice.lazy.FineGrainedLazySingletonScope -->
  <class name="FineGrainedLazySingletonScope" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="Use javax.inject.Singleton instead.  FineGrainedLazySingleton is not needed 
 as of Guice4 which fixes the global lock issue.">
    <constructor name="FineGrainedLazySingletonScope"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="Scope"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the scope
 @return scope]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A singleton factory that returns a Guice {@link Scope} that enables fine grained lazy singletons.

 @see FineGrainedLazySingleton
 @deprecated Use javax.inject.Singleton instead.  FineGrainedLazySingleton is not needed 
 as of Guice4 which fixes the global lock issue.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.lazy.FineGrainedLazySingletonScope -->
  <!-- start class com.netflix.governator.guice.lazy.LazySingleton -->
  <class name="LazySingleton"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.annotation.Annotation"/>
    <doc>
    <![CDATA[Scope annotation that marks a class as singleton that should NOT be
 allocated eagerly]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.lazy.LazySingleton -->
  <!-- start class com.netflix.governator.guice.lazy.LazySingletonScope -->
  <class name="LazySingletonScope" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="Scope"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the scope
 @return scope]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A singleton factory that returns a Guice {@link Scope} that enables lazy singletons]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.lazy.LazySingletonScope -->
</package>
<package name="com.netflix.governator.guice.main">
  <!-- start class com.netflix.governator.guice.main.Arguments -->
  <class name="Arguments" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Arguments" type="java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getArguments" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Placeholder for command line arguments.  For now the placeholder only contains the 
 command line arguments but may be extended to include additional application context.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.main.Arguments -->
  <!-- start class com.netflix.governator.guice.main.BootstrapMain -->
  <class name="BootstrapMain" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BootstrapMain"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
    </method>
    <doc>
    <![CDATA[Main class for loading a bootstrap configuration via main().  When running an application set
 this to the main class and set the first argument to the name of the bootstrap'd class.
 
 java BootstrapMain com.org.MyApplicationBootstrap ...
 
 Where,
 
 <pre>
 {@code
  @GovernatorConfiguration
  public class MyApplicationBootstrap extends AbstractModule {
     public void configure() {
        // your application bindings here
     }
  }
 }
 </pre>
 
 Note that any component in your application can gain access to the command line arguments by injecting
 Arguments.  Also, it is the responsibility of your application to parse the command line and manage
 the application lifecycle.  In the future there may be governator subprojects for various cli parsing
 and command line processing libraries (such as apache commons cli)
 
 <pre>
 {@code
 @Singleton
 public class MyApplication {
    @Inject
    MyApplication(Arguments args) {
    }
 }
 }
 </pre>
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.main.BootstrapMain -->
</package>
<package name="com.netflix.governator.guice.runner">
  <!-- start interface com.netflix.governator.guice.runner.LifecycleRunner -->
  <interface name="LifecycleRunner"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <doc>
    <![CDATA[Abstraction defining the application runtime framework for an application using
 Governator.  If a binding for ApplicationFramework exists Governator will
 create the instance of the ApplicationFramework immediately after creating
 the bootstrap module.  It is the application framework's responsibility
 to call {@link com.netflix.governator.lifecycle.LifecycleManager LifecycleManager}
 start and stop as well as manage the application termination mechanism.

 A {@link StandaloneRunnerModule} is provided for simple command line
 applications.

 Additional LifecycleRunner implementations may be provided for running
 Jetty, Karyon, etc...

 @author elandau]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.guice.runner.LifecycleRunner -->
  <!-- start interface com.netflix.governator.guice.runner.TerminationEvent -->
  <interface name="TerminationEvent"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="await"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Block until the termination event is fired.
 
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="terminate"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Fire the termination event.]]>
      </doc>
    </method>
    <method name="isTerminated" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return True if the termination event was set.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstraction for an event that when fired should tell the LifecycleRunner 
 to terminate.  A concrete TerminatEvent type is normally paired with a
 specific runner implementation.
 
 @author elandau

 TODO: Add additional listeners of the termination event]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.guice.runner.TerminationEvent -->
</package>
<package name="com.netflix.governator.guice.runner.events">
  <!-- start class com.netflix.governator.guice.runner.events.BlockingTerminationEvent -->
  <class name="BlockingTerminationEvent" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.runner.TerminationEvent"/>
    <constructor name="BlockingTerminationEvent"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="await"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="terminate"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isTerminated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Simple TerminatEvent using a countdown latch as the termination signal.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.runner.events.BlockingTerminationEvent -->
  <!-- start class com.netflix.governator.guice.runner.events.SelfDestructingTerminationEvent -->
  <class name="SelfDestructingTerminationEvent" extends="com.netflix.governator.guice.runner.events.BlockingTerminationEvent"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SelfDestructingTerminationEvent" type="long, java.util.concurrent.TimeUnit"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Used mainly for testing the SelfDestructingTerminationEvent will fire the main TerminateEvent
 after a specified amount of time has elapsed, causing the application to exit.
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.runner.events.SelfDestructingTerminationEvent -->
</package>
<package name="com.netflix.governator.guice.runner.standalone">
  <!-- start class com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule -->
  <class name="StandaloneRunnerModule" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.BootstrapModule"/>
    <constructor name="StandaloneRunnerModule" type="java.lang.String[], java.lang.Class&lt;?&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="builder" return="com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule.Builder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.netflix.governator.guice.BootstrapBinder"/>
    </method>
    <doc>
    <![CDATA[Implementation of a Runner module that should be used for runtime applications.

 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule -->
  <!-- start class com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule.Builder -->
  <class name="StandaloneRunnerModule.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="withArgs" return="com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Specify optional command line arguments to be injected.  The arguments can be injected
 as

 <code>
      &#64;Main List<String>
 </code>
 @param args]]>
      </doc>
    </method>
    <method name="withMainClass" return="com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="main" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Specify an optional main class to instantiate.  Alternatively the
 main class can be added as an eager singleton
 @param main]]>
      </doc>
    </method>
    <method name="withTerminateEvent" return="com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="event" type="com.netflix.governator.guice.runner.TerminationEvent"/>
      <doc>
      <![CDATA[Specify an externally provided {@link TerminationEvent}.  If not specified
 the default {@link BlockingTerminationEvent} will be used.
 @param event]]>
      </doc>
    </method>
    <method name="build" return="com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[This builder simplifies creation of the module in main()]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule.Builder -->
  <!-- start class com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule.MainInjectorModule -->
  <class name="StandaloneRunnerModule.MainInjectorModule" extends="AbstractModule"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MainInjectorModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule.MainInjectorModule -->
  <!-- start class com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule.StandaloneFramework -->
  <class name="StandaloneRunnerModule.StandaloneFramework" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.runner.LifecycleRunner"/>
    <constructor name="StandaloneFramework"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[This is the application's main 'run' loop. which blocks on the termination event]]>
      </doc>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.runner.standalone.StandaloneRunnerModule.StandaloneFramework -->
</package>
<package name="com.netflix.governator.guice.serviceloader">
  <!-- start class com.netflix.governator.guice.serviceloader.ServiceLoaderBootstrapModule -->
  <class name="ServiceLoaderBootstrapModule" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.BootstrapModule"/>
    <constructor name="ServiceLoaderBootstrapModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ServiceLoaderBootstrapModule" type="java.lang.Class&lt;? extends Module&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binder" type="com.netflix.governator.guice.BootstrapBinder"/>
    </method>
    <doc>
    <![CDATA[BootstrapModule that loads guice modules via the ServiceLoader.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.serviceloader.ServiceLoaderBootstrapModule -->
  <!-- start class com.netflix.governator.guice.serviceloader.ServiceLoaderModule -->
  <class name="ServiceLoaderModule" extends="AbstractModule"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceLoaderModule"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="configureServices"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="bindServices" return="com.netflix.governator.guice.serviceloader.ServiceLoaderModule.ServiceBinder&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;S&gt;"/>
      <doc>
      <![CDATA[Load services and make them available via a Set<S> binding using 
 multi-binding.  Note that this methods loads services lazily but also
 allows for additional bindings to be done via Guice modules.
 
 @param type]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simple Guice module to integrate with the {@link ServiceLoader}.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.serviceloader.ServiceLoaderModule -->
  <!-- start interface com.netflix.governator.guice.serviceloader.ServiceLoaderModule.ServiceBinder -->
  <interface name="ServiceLoaderModule.ServiceBinder"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="usingClassLoader" return="com.netflix.governator.guice.serviceloader.ServiceLoaderModule.ServiceBinder&lt;S&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classLoader" type="java.lang.ClassLoader"/>
    </method>
    <method name="forInstalledServices" return="com.netflix.governator.guice.serviceloader.ServiceLoaderModule.ServiceBinder&lt;S&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="installed" type="java.lang.Boolean"/>
    </method>
    <method name="usingMultibinding" return="com.netflix.governator.guice.serviceloader.ServiceLoaderModule.ServiceBinder&lt;S&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="usingMultibinding" type="java.lang.Boolean"/>
    </method>
  </interface>
  <!-- end interface com.netflix.governator.guice.serviceloader.ServiceLoaderModule.ServiceBinder -->
  <!-- start class com.netflix.governator.guice.serviceloader.ServiceLoaderModule.ServiceProvider -->
  <class name="ServiceLoaderModule.ServiceProvider" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceProvider" type="S"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="S"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptExtensionVisitor" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="&lt;any&gt;"/>
      <param name="binding" type="&lt;any&gt;"/>
    </method>
    <doc>
    <![CDATA[Custom provider that allows for member injection of a service.  Note that while the
 service was instantiated at binding time the members injection won't happen until the
 set of services is injected.
 
 @author elandau

 @param <S>]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.serviceloader.ServiceLoaderModule.ServiceProvider -->
  <!-- start class com.netflix.governator.guice.serviceloader.ServiceLoaderModule.ServiceSetProvider -->
  <class name="ServiceLoaderModule.ServiceSetProvider" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ServiceSetProvider" type="java.util.concurrent.Callable&lt;java.util.ServiceLoader&lt;S&gt;&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.util.Set&lt;S&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="acceptExtensionVisitor" return="V"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="visitor" type="&lt;any&gt;"/>
      <param name="binding" type="&lt;any&gt;"/>
    </method>
    <doc>
    <![CDATA[Custom provider that enables member injection on services
 
 @author elandau

 @param <S>]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.serviceloader.ServiceLoaderModule.ServiceSetProvider -->
</package>
<package name="com.netflix.governator.guice.servlet">
  <!-- start class com.netflix.governator.guice.servlet.GovernatorServletContextListener -->
  <class name="GovernatorServletContextListener" extends="GuiceServletContextListener"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="GovernatorServletContextListener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="contextInitialized"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletContextEvent" type="ServletContextEvent"/>
    </method>
    <method name="contextDestroyed"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="servletContextEvent" type="ServletContextEvent"/>
    </method>
    <method name="getInjector" return="Injector"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Override this method to create (or otherwise obtain a reference to) your
 injector.]]>
      </doc>
    </method>
    <method name="createInjector" return="Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <field name="LOG" type="Logger"
      transient="false" volatile="false"
      static="true" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An extension of {@link GuiceServletContextListener} which integrates with Governator's
 LifecycleInjector.  This implementation drives shutdown of LifecycleManager through the 
 ServletContextListener's contextDestroyed event.  
 
 To use, subclass your main server class from GovernatorServletContextListener
 <pre>
 {@code 
 
package com.cloudservice.StartServer;
public class StartServer extends GovernatorServletContextListener
{
    @Override
    protected Injector createInjector() {
        return Governator.createInjector(
            new JerseyServletModule() {
                @Override
                protected void configureServlets() {
                    serve("/REST/*").with(GuiceContainer.class);
                    binder().bind(GuiceContainer.class).asEagerSingleton();
                    
                    bind(MyResource.class).asEagerSingleton();
                }
            }
        );
    }
}
 }
 </pre>
 
 Then reference this class from web.xml.

 <PRE>
     &lt;filter&gt;
         &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
         &lt;filter-class&gt;com.google.inject.servlet.GuiceFilter&lt;/filter-class&gt;
     &lt;/filter&gt;

     &lt;filter-mapping&gt;
         &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
         &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
     &lt;/filter-mapping&gt;

     &lt;listener&gt;
         &lt;listener-class&gt;com.cloudservice.StartServer&lt;/listener-class&gt;
     &lt;/listener&gt;

 </PRE>

 @author Eran Landau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.servlet.GovernatorServletContextListener -->
  <!-- start class com.netflix.governator.guice.servlet.JspDispatchServlet -->
  <class name="JspDispatchServlet" extends="HttpServlet"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JspDispatchServlet"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doGet"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="req" type="HttpServletRequest"/>
      <param name="resp" type="HttpServletResponse"/>
      <exception name="ServletException" type="ServletException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[This service is a hack to solve a bug in Guice's serving of jsp files.  

 To enable add this line to your ServletModule
 <pre>
 {@code
 serveRegex("/.\*\.jsp").with(JspDispatchServlet.class);
 bind(JspDispatchServlet.class).asEagerSingleton();
 }
 </pre>
             
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.servlet.JspDispatchServlet -->
</package>
<package name="com.netflix.governator.guice.transformer">
  <!-- start class com.netflix.governator.guice.transformer.OverrideAllDuplicateBindings -->
  <class name="OverrideAllDuplicateBindings" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.ModuleTransformer"/>
    <constructor name="OverrideAllDuplicateBindings"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="call" return="java.util.Collection&lt;Module&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.Collection&lt;Module&gt;"/>
    </method>
    <doc>
    <![CDATA[Treat any binding in list order as an override for previous bindings.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.guice.transformer.OverrideAllDuplicateBindings -->
  <!-- start class com.netflix.governator.guice.transformer.StripStaticInjections -->
  <class name="StripStaticInjections" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.ModuleTransformer"/>
    <constructor name="StripStaticInjections"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="call" return="java.util.Collection&lt;Module&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.Collection&lt;Module&gt;"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.transformer.StripStaticInjections -->
  <!-- start class com.netflix.governator.guice.transformer.WarnAboutStaticInjections -->
  <class name="WarnAboutStaticInjections" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.guice.ModuleTransformer"/>
    <constructor name="WarnAboutStaticInjections"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="call" return="java.util.Collection&lt;Module&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.Collection&lt;Module&gt;"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.guice.transformer.WarnAboutStaticInjections -->
</package>
<package name="com.netflix.governator.internal">
  <!-- start class com.netflix.governator.internal.DefaultPropertySource -->
  <class name="DefaultPropertySource" extends="com.netflix.governator.AbstractPropertySource"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="DefaultPropertySource"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
    </method>
    <method name="hasProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[PropertySource based on system and environment properties with 
 system properties having precedence. 
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.internal.DefaultPropertySource -->
  <!-- start interface com.netflix.governator.internal.GovernatorFeatureSet -->
  <interface name="GovernatorFeatureSet"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="feature" type="com.netflix.governator.GovernatorFeature&lt;T&gt;"/>
      <doc>
      <![CDATA[@return Get the value of the feature or the default if none is set]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Container of Governator features.]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.internal.GovernatorFeatureSet -->
  <!-- start class com.netflix.governator.internal.ModulesEx -->
  <class name="ModulesEx" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="ModulesEx"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="emptyModule" return="Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="fromEagerSingleton" return="Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
    </method>
    <method name="fromInstance" return="Module"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="object" type="T"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.internal.ModulesEx -->
  <!-- start class com.netflix.governator.internal.PostConstructLifecycleActions -->
  <class name="PostConstructLifecycleActions" extends="com.netflix.governator.internal.AbstractLifecycleFeature"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMethodActions" return="java.util.List&lt;com.netflix.governator.LifecycleAction&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <param name="method" type="java.lang.reflect.Method"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="INSTANCE" type="com.netflix.governator.internal.PostConstructLifecycleActions"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Special AbstractLifecycleFeature to support @PostConstruct annotation processing.
 Note that this feature is implicit in LifecycleModule and therefore does not need 
 to be added using the LifecycleFeature multibinding.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.internal.PostConstructLifecycleActions -->
  <!-- start class com.netflix.governator.internal.PreDestroyLifecycleActions -->
  <class name="PreDestroyLifecycleActions" extends="com.netflix.governator.internal.AbstractLifecycleFeature"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getMethodActions" return="java.util.List&lt;com.netflix.governator.LifecycleAction&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;?&gt;"/>
      <param name="method" type="java.lang.reflect.Method"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="INSTANCE" type="com.netflix.governator.internal.PreDestroyLifecycleActions"
      transient="false" volatile="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Special AbstractLifecycleFeature to support @PreDestroy annotation processing.
 Note that this feature is implicit in LifecycleModule and therefore does not need 
 to be added using the LifecycleFeature multibinding.
 
 @author elandau]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.internal.PreDestroyLifecycleActions -->
</package>
<package name="com.netflix.governator.lifecycle">
  <!-- start class com.netflix.governator.lifecycle.AnnotationFinder -->
  <class name="AnnotationFinder" extends="ClassVisitor"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="AnnotationFinder" type="java.lang.ClassLoader, java.util.Collection&lt;java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="version" type="int"/>
      <param name="access" type="int"/>
      <param name="name" type="java.lang.String"/>
      <param name="signature" type="java.lang.String"/>
      <param name="superName" type="java.lang.String"/>
      <param name="interfaces" type="java.lang.String[]"/>
    </method>
    <method name="visitAnnotation" return="AnnotationVisitor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="desc" type="java.lang.String"/>
      <param name="visible" type="boolean"/>
    </method>
    <method name="visitField" return="FieldVisitor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="access" type="int"/>
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="signature" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
    </method>
    <method name="visitMethod" return="MethodVisitor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="access" type="int"/>
      <param name="name" type="java.lang.String"/>
      <param name="desc" type="java.lang.String"/>
      <param name="signature" type="java.lang.String"/>
      <param name="exceptions" type="java.lang.String[]"/>
    </method>
    <method name="getAnnotatedClasses" return="java.util.Set&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return a 0 or 1 element Set, depending on whether the class being
         visited has a matching class annotation]]>
      </doc>
    </method>
    <method name="getAnnotatedMethods" return="java.util.Set&lt;java.lang.reflect.Method&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAnnotatedConstructors" return="java.util.Set&lt;java.lang.reflect.Constructor&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getAnnotatedFields" return="java.util.Set&lt;java.lang.reflect.Field&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.netflix.governator.lifecycle.AnnotationFinder -->
  <!-- start class com.netflix.governator.lifecycle.ClasspathScanner -->
  <class name="ClasspathScanner" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClasspathScanner" type="java.util.Collection&lt;java.lang.String&gt;, java.util.Collection&lt;java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param basePackages list of packages to search (recursively)
 @param annotations class annotations to search for]]>
      </doc>
    </constructor>
    <constructor name="ClasspathScanner" type="java.util.Collection&lt;java.lang.String&gt;, java.util.Collection&lt;java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;&gt;, java.lang.ClassLoader"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param basePackages list of packages to search (recursively)
 @param annotations class annotations to search for
 @param classLoader ClassLoader containing the classes to be scanned]]>
      </doc>
    </constructor>
    <method name="getClasses" return="java.util.Set&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the found classes]]>
      </doc>
    </method>
    <method name="getConstructors" return="java.util.Set&lt;java.lang.reflect.Constructor&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMethods" return="java.util.Set&lt;java.lang.reflect.Method&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFields" return="java.util.Set&lt;java.lang.reflect.Field&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="doScanning"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="basePackages" type="java.util.Collection&lt;java.lang.String&gt;"/>
      <param name="annotations" type="java.util.Collection&lt;java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;&gt;"/>
      <param name="localClasses" type="java.util.Set&lt;java.lang.Class&lt;?&gt;&gt;"/>
      <param name="localConstructors" type="java.util.Set&lt;java.lang.reflect.Constructor&gt;"/>
      <param name="localMethods" type="java.util.Set&lt;java.lang.reflect.Method&gt;"/>
      <param name="localFields" type="java.util.Set&lt;java.lang.reflect.Field&gt;"/>
    </method>
    <field name="classLoader" type="java.lang.ClassLoader"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Utility to find annotated classes]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.lifecycle.ClasspathScanner -->
  <!-- start class com.netflix.governator.lifecycle.ClasspathUrlDecoder -->
  <class name="ClasspathUrlDecoder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ClasspathUrlDecoder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="toFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
    </method>
    <method name="decode" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fileName" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.lifecycle.ClasspathUrlDecoder -->
  <!-- start class com.netflix.governator.lifecycle.DefaultConfigurationMapper -->
  <class name="DefaultConfigurationMapper" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.configuration.ConfigurationMapper"/>
    <constructor name="DefaultConfigurationMapper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="mapConfiguration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configurationProvider" type="com.netflix.governator.configuration.ConfigurationProvider"/>
      <param name="configurationDocumentation" type="com.netflix.governator.configuration.ConfigurationDocumentation"/>
      <param name="obj" type="java.lang.Object"/>
      <param name="methods" type="com.netflix.governator.lifecycle.LifecycleMethods"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.lifecycle.DefaultConfigurationMapper -->
  <!-- start class com.netflix.governator.lifecycle.DefaultLifecycleListener -->
  <class name="DefaultLifecycleListener" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.lifecycle.LifecycleListener"/>
    <constructor name="DefaultLifecycleListener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="objectInjected"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
      <param name="obj" type="T"/>
    </method>
    <method name="objectInjected"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
      <param name="obj" type="T"/>
      <param name="duration" type="long"/>
      <param name="units" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="stateChanged"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="newState" type="com.netflix.governator.lifecycle.LifecycleState"/>
    </method>
    <method name="objectInjecting"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.lifecycle.DefaultLifecycleListener -->
  <!-- start class com.netflix.governator.lifecycle.FilteredLifecycleListener -->
  <class name="FilteredLifecycleListener" extends="com.netflix.governator.lifecycle.DefaultLifecycleListener"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="FilteredLifecycleListener" type="com.netflix.governator.lifecycle.LifecycleListener, java.lang.String[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param listener actual listener
 @param basePackages set of base packages]]>
      </doc>
    </constructor>
    <constructor name="FilteredLifecycleListener" type="com.netflix.governator.lifecycle.LifecycleListener, java.util.Collection&lt;java.lang.String&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param listener actual listener
 @param basePackages set of base packages]]>
      </doc>
    </constructor>
    <method name="objectInjected"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
      <param name="obj" type="T"/>
    </method>
    <method name="stateChanged"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="newState" type="com.netflix.governator.lifecycle.LifecycleState"/>
    </method>
    <doc>
    <![CDATA[Wrapper listener that forwards to the provided listener only when the obj is in one of the
 specified base packages.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.lifecycle.FilteredLifecycleListener -->
  <!-- start class com.netflix.governator.lifecycle.LifecycleConfigurationProviders -->
  <class name="LifecycleConfigurationProviders" extends="com.netflix.governator.configuration.CompositeConfigurationProvider"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LifecycleConfigurationProviders" type="com.netflix.governator.configuration.ConfigurationProvider[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifecycleConfigurationProviders" type="java.util.Collection&lt;com.netflix.governator.configuration.ConfigurationProvider&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.netflix.governator.lifecycle.LifecycleConfigurationProviders -->
  <!-- start interface com.netflix.governator.lifecycle.LifecycleListener -->
  <interface name="LifecycleListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="objectInjected"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
      <param name="obj" type="T"/>
      <doc>
      <![CDATA[When Guice injects an object, this callback will be notified

 @param type object type being injected
 @param obj  object being injected]]>
      </doc>
    </method>
    <method name="objectInjected"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
      <param name="obj" type="T"/>
      <param name="duration" type="long"/>
      <param name="units" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Notification that an object has been injected and the amount of time it to either 
 construct or retrieve the object.  This call is in addition to the objectInjected
 above and is currently only called when constructing via ConcurrentProvider
 
 @param type
 @param obj
 @param duration
 @param units]]>
      </doc>
    </method>
    <method name="stateChanged"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="newState" type="com.netflix.governator.lifecycle.LifecycleState"/>
      <doc>
      <![CDATA[Called when an object's lifecycle state changes

 @param obj      the object
 @param newState new state]]>
      </doc>
    </method>
    <method name="objectInjecting"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
      <doc>
      <![CDATA[Notification that an object is being injected.  This call is only made when injecting
 using ConcurrentProvider
 @param type]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Callback for injected instances]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.lifecycle.LifecycleListener -->
  <!-- start class com.netflix.governator.lifecycle.LifecycleManager -->
  <class name="LifecycleManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="LifecycleManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifecycleManager" type="com.netflix.governator.lifecycle.LifecycleManagerArguments"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifecycleManager" type="com.netflix.governator.lifecycle.LifecycleManagerArguments, Injector"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getListeners" return="java.util.Collection&lt;com.netflix.governator.lifecycle.LifecycleListener&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the lifecycle listener if any

 @return listener or null]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objects" type="java.lang.Object[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Add the objects to the container. Their assets will be loaded, post construct methods called, etc.

 @param objects objects to add
 @throws Exception errors]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Add the object to the container. Its assets will be loaded, post construct methods called, etc.

 @param obj object to add
 @throws Exception errors]]>
      </doc>
    </method>
    <method name="add"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="methods" type="com.netflix.governator.lifecycle.LifecycleMethods"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Add the object to the container. Its assets will be loaded, post construct methods called, etc.
 This version helps performance when the lifecycle methods have already been calculated

 @param obj     object to add
 @param methods calculated lifecycle methods
 @throws Exception errors]]>
      </doc>
    </method>
    <method name="hasStarted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the lifecycle has started (i.e. {@link #start()} has been called).

 @return true/false]]>
      </doc>
    </method>
    <method name="getState" return="com.netflix.governator.lifecycle.LifecycleState"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <doc>
      <![CDATA[Return the current state of the given object or LATENT if unknown

 @param obj object to check
 @return state]]>
      </doc>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[The manager MUST be started. Note: this method
 waits indefinitely for warm up methods to complete

 @throws Exception errors]]>
      </doc>
    </method>
    <method name="start" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxWait" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[The manager MUST be started. This version of start() has a maximum
 wait period for warm up methods.

 @param maxWait maximum wait time for warm up methods - if the time elapses, the warm up methods are interrupted
 @param unit    time unit
 @return true if warm up methods successfully executed, false if the time elapses
 @throws Exception errors]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="validate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ValidationException" type="com.netflix.governator.lifecycle.ValidationException"/>
      <doc>
      <![CDATA[Run the validations on the managed objects. This is done automatically when {@link #start()} is called.
 But you can call this at any time you need.

 @throws ValidationException]]>
      </doc>
    </method>
    <method name="validate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <exception name="ValidationException" type="com.netflix.governator.lifecycle.ValidationException"/>
      <doc>
      <![CDATA[Run validations on the given object

 @param obj the object to validate
 @throws ValidationException]]>
      </doc>
    </method>
    <method name="getDAGManager" return="com.netflix.governator.lifecycle.warmup.DAGManager"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the internal DAG manager]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Main instance management container]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.lifecycle.LifecycleManager -->
  <!-- start class com.netflix.governator.lifecycle.LifecycleManagerArguments -->
  <class name="LifecycleManagerArguments" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LifecycleManagerArguments" type="com.netflix.governator.configuration.ConfigurationDocumentation, com.netflix.governator.configuration.ConfigurationMapper, com.netflix.governator.configuration.ConfigurationProvider"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="LifecycleManagerArguments"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getConfigurationMapper" return="com.netflix.governator.configuration.ConfigurationMapper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConfigurationMapper"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configurationMapper" type="com.netflix.governator.configuration.ConfigurationMapper"/>
    </method>
    <method name="getConfigurationProvider" return="com.netflix.governator.configuration.ConfigurationProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLifecycleListeners" return="java.util.Collection&lt;com.netflix.governator.lifecycle.LifecycleListener&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConfigurationProvider"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configurationProvider" type="com.netflix.governator.configuration.ConfigurationProvider"/>
    </method>
    <method name="setLifecycleListeners"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="lifecycleListeners" type="java.util.Collection&lt;com.netflix.governator.lifecycle.LifecycleListener&gt;"/>
    </method>
    <method name="getPostStartArguments" return="com.netflix.governator.lifecycle.PostStartArguments"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setPostStartArguments"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="postStartArguments" type="com.netflix.governator.lifecycle.PostStartArguments"/>
    </method>
    <method name="getResourceLocators" return="java.util.Set&lt;com.netflix.governator.lifecycle.ResourceLocator&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setResourceLocators"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="resourceLocators" type="java.util.Set&lt;com.netflix.governator.lifecycle.ResourceLocator&gt;"/>
    </method>
    <method name="setConfigurationDocumentation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configurationDocumentation" type="com.netflix.governator.configuration.ConfigurationDocumentation"/>
    </method>
    <method name="getConfigurationDocumentation" return="com.netflix.governator.configuration.ConfigurationDocumentation"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="DEFAULT_WARM_UP_PADDING_MS" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
  </class>
  <!-- end class com.netflix.governator.lifecycle.LifecycleManagerArguments -->
  <!-- start class com.netflix.governator.lifecycle.LifecycleMethods -->
  <class name="LifecycleMethods" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LifecycleMethods" type="java.lang.Class&lt;?&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hasLifecycleAnnotations" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="methodsFor" return="java.util.Collection&lt;java.lang.reflect.Method&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
    </method>
    <method name="fieldsFor" return="java.util.Collection&lt;java.lang.reflect.Field&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;"/>
    </method>
    <method name="classAnnotationsFor" return="java.util.Collection&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="annotation" type="java.lang.Class&lt;T&gt;"/>
    </method>
    <doc>
    <![CDATA[Used internally to hold the methods important to the LifecycleManager]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.lifecycle.LifecycleMethods -->
  <!-- start class com.netflix.governator.lifecycle.LifecycleState -->
  <class name="LifecycleState" extends="java.lang.Enum&lt;com.netflix.governator.lifecycle.LifecycleState&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="com.netflix.governator.lifecycle.LifecycleState[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="com.netflix.governator.lifecycle.LifecycleState"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Possible states for a managed object]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.lifecycle.LifecycleState -->
  <!-- start class com.netflix.governator.lifecycle.LoggingLifecycleListener -->
  <class name="LoggingLifecycleListener" extends="com.netflix.governator.lifecycle.DefaultLifecycleListener"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="LoggingLifecycleListener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="objectInjected"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
      <param name="obj" type="T"/>
    </method>
    <method name="stateChanged"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="newState" type="com.netflix.governator.lifecycle.LifecycleState"/>
    </method>
    <method name="objectInjected"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
      <param name="obj" type="T"/>
      <param name="duration" type="long"/>
      <param name="units" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="objectInjecting"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="&lt;any&gt;"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.lifecycle.LoggingLifecycleListener -->
  <!-- start interface com.netflix.governator.lifecycle.PostStartArguments -->
  <interface name="PostStartArguments"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getWarmUpErrorHandler" return="com.netflix.governator.lifecycle.PostStartArguments.WarmUpErrorHandler"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the wam up error handler

 @return error handler]]>
      </doc>
    </method>
    <method name="getWarmUpPaddingMs" return="long"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[When performing warm ups after {@link LifecycleManager#start()} has been called
 the warm up processor will wait a given period of time (default is 3 seconds) so
 that any other warm up methods can be called together.

 @return time in milliseconds to wait (default is 3 seconds)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Arguments used by {@link LifecycleManager} after {@link LifecycleManager#start()} has been called.
 Bind an instance to this interface in the {@link BootstrapBinder} to override defaults.]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.lifecycle.PostStartArguments -->
  <!-- start interface com.netflix.governator.lifecycle.PostStartArguments.WarmUpErrorHandler -->
  <interface name="PostStartArguments.WarmUpErrorHandler"    abstract="true"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="warmUpError"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exception" type="com.netflix.governator.lifecycle.warmup.WarmUpException"/>
      <doc>
      <![CDATA[Handle a warm up error. Default behavior is to log and call {@link System#exit(int)}

 @param exception the error container]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Called when there was a warm up error]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.lifecycle.PostStartArguments.WarmUpErrorHandler -->
  <!-- start interface com.netflix.governator.lifecycle.ResourceLocator -->
  <interface name="ResourceLocator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="locate" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="resource" type="javax.annotation.Resource"/>
      <param name="nextInChain" type="com.netflix.governator.lifecycle.ResourceLocator"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[Load and return the given resource. If you cannot or do not wish to load
 it, pass on to the next locator in the chain. NOTE: the default ResourceLocator
 merely throws {@link NameNotFoundException}.

 @param resource the resource to load - NOTE: type() and name() will have been adjusted if defaults were used.
 @param nextInChain the next locator in the chain (never <code>null</code>)
 @return the loaded object
 @throws Exception errors]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Used to load {@link Resource} and {@link Resources} annotated objects. Bind
 one or more instances via {@link BootstrapBinder#bindResourceLocator()}.]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.lifecycle.ResourceLocator -->
  <!-- start class com.netflix.governator.lifecycle.ValidationException -->
  <class name="ValidationException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ValidationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ValidationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
  </class>
  <!-- end class com.netflix.governator.lifecycle.ValidationException -->
</package>
<package name="com.netflix.governator.lifecycle.warmup">
  <!-- start class com.netflix.governator.lifecycle.warmup.DAGManager -->
  <class name="DAGManager" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DAGManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="newCopyAndClear" return="com.netflix.governator.lifecycle.warmup.DAGManager"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a copy of this DAGManager and then clears this instance

 @return copy]]>
      </doc>
    </method>
    <method name="addObjectMapping"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectKey" type="java.lang.Object"/>
      <param name="object" type="java.lang.Object"/>
      <param name="methods" type="com.netflix.governator.lifecycle.LifecycleMethods"/>
      <doc>
      <![CDATA[Adds a mapping of an object "key" to an object

 @param objectKey the object's key
 @param object    the object
 @param methods   the objects lifecycle methods]]>
      </doc>
    </method>
    <method name="addDependency"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="objectKey" type="java.lang.Object"/>
      <param name="dependencyKey" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds a dependency for the given object

 @param objectKey     object's key
 @param dependencyKey object key of the dependency]]>
      </doc>
    </method>
    <method name="buildTree" return="com.netflix.governator.lifecycle.warmup.DependencyNode"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Build the dependencies into a DAG

 @return root of the DAG]]>
      </doc>
    </method>
    <method name="getObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="getLifecycleMethods" return="com.netflix.governator.lifecycle.LifecycleMethods"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.Object"/>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Manages building of dependencies]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.lifecycle.warmup.DAGManager -->
  <!-- start interface com.netflix.governator.lifecycle.warmup.WarmUpDriver -->
  <interface name="WarmUpDriver"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setPreWarmUpState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setPostWarmUpState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPostStartArguments" return="com.netflix.governator.lifecycle.PostStartArguments"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setState"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
      <param name="state" type="com.netflix.governator.lifecycle.LifecycleState"/>
    </method>
  </interface>
  <!-- end interface com.netflix.governator.lifecycle.warmup.WarmUpDriver -->
  <!-- start class com.netflix.governator.lifecycle.warmup.WarmUpErrors -->
  <class name="WarmUpErrors" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable&lt;com.netflix.governator.lifecycle.warmup.WarmUpErrors.Error&gt;"/>
    <constructor name="WarmUpErrors"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="addError" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="e" type="java.lang.Throwable"/>
      <param name="context" type="java.lang.String"/>
      <doc>
      <![CDATA[Add an error and resolve to its cause if needed

 @param e error
 @param context error context
 @return resolved error]]>
      </doc>
    </method>
    <method name="throwIfErrors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="WarmUpException" type="com.netflix.governator.lifecycle.warmup.WarmUpException"/>
      <doc>
      <![CDATA[Throw a WarmUpException if there are errors

 @throws WarmUpException if there are errors]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator&lt;com.netflix.governator.lifecycle.warmup.WarmUpErrors.Error&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Container for errors that occur in warm up methods]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.lifecycle.warmup.WarmUpErrors -->
  <!-- start class com.netflix.governator.lifecycle.warmup.WarmUpErrors.Error -->
  <class name="WarmUpErrors.Error" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getException" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return The error]]>
      </doc>
    </method>
    <method name="getContext" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return object/context of the error]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Record of a single error]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.lifecycle.warmup.WarmUpErrors.Error -->
  <!-- start class com.netflix.governator.lifecycle.warmup.WarmUpException -->
  <class name="WarmUpException" extends="java.lang.Exception"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getErrors" return="com.netflix.governator.lifecycle.warmup.WarmUpErrors"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@return the errors]]>
      </doc>
    </method>
    <method name="getMessage" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="printStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="printStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.io.PrintStream"/>
    </method>
    <method name="printStackTrace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.PrintWriter"/>
    </method>
    <doc>
    <![CDATA[Thrown by {@link LifecycleManager#start()} if there are errors in warm up methods]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.lifecycle.warmup.WarmUpException -->
  <!-- start class com.netflix.governator.lifecycle.warmup.WarmUpSession -->
  <class name="WarmUpSession" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WarmUpSession" type="com.netflix.governator.lifecycle.warmup.WarmUpDriver, com.netflix.governator.lifecycle.warmup.DAGManager"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="doImmediate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="maxMs" type="long"/>
      <exception name="Exception" type="java.lang.Exception"/>
    </method>
    <method name="doInBackground"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class com.netflix.governator.lifecycle.warmup.WarmUpSession -->
  <!-- start class com.netflix.governator.lifecycle.warmup.WarmUpTask -->
  <class name="WarmUpTask" extends="java.util.concurrent.RecursiveAction"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WarmUpTask" type="com.netflix.governator.lifecycle.warmup.WarmUpDriver, com.netflix.governator.lifecycle.warmup.WarmUpErrors, com.netflix.governator.lifecycle.warmup.DAGManager, java.util.concurrent.ConcurrentMap&lt;java.lang.Object, com.netflix.governator.lifecycle.warmup.WarmUpTask&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@param warmUpDriver the warmUpDriver
 @param errors container for warm up errors]]>
      </doc>
    </constructor>
    <method name="compute"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
     A Fork Join task to warm up objects. Each node's dependency's
     are warmed-up via forking before the node itself warms-up.
 </p>

 <p>
     Thanks to Allan Pratt for his help and design ideas
 </p>]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.lifecycle.warmup.WarmUpTask -->
</package>
<package name="com.netflix.governator.providers">
  <!-- start class com.netflix.governator.providers.SingletonProvider -->
  <class name="SingletonProvider" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SingletonProvider"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="get" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the caches instance or call the internal {@link create} method
 when creating the object for the first time.]]>
      </doc>
    </method>
    <method name="create" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Implement the actual object creation here instead of in get()
 @return]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Base class for {@link Providers} that which to enforce singleton semantics
 for a type.
 
 Note that this class is needed since annotating a Provider with @Singleton
 makes the Provider a singleton and NOT the type is it providing.  So the
 same Provider is returned when the Provider is injector the a new call to 
 get() is made whenever the type T is injected.
 
 @author elandau

 @param <T>]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.providers.SingletonProvider -->
</package>
<package name="com.netflix.governator.spi">
  <!-- start interface com.netflix.governator.spi.InjectorCreator -->
  <interface name="InjectorCreator"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="createInjector" return="I extends Injector"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="stage" type="Stage"/>
      <param name="module" type="Module"/>
    </method>
    <doc>
    <![CDATA[Contract that makes Guice injector creation a pluggable strategy and allows for typed
 extensions to the Injector within the context of the strategy.  An InjectorCreator
 may also implement post injector creation operations such as calling {@link LifecycleListener}s
 prior to returning form createInjector().
 
 InjectorCreator can be used directly with a module,
 
 <code>
   new LifecycleInjectorCreator().createInjector(new MyApplicationModule());
 </code>
 
 Alternatively, InjectorCreator can be used in conjunction with the {@link InjectorBuilder} DSL 
 
 <code>
  LifecycleInjector injector = InjectorBuilder
      .fromModule(new MyApplicationModule())
      .overrideWith(new MyApplicationOverrideModule())
      .combineWith(new AdditionalModule()
      .createInjector(new LifecycleInjectorCreator());
  }
 </code>
 
 See {@link SimpleInjectorCreator} or {@link LifecycleInjectorCreator}]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.spi.InjectorCreator -->
  <!-- start interface com.netflix.governator.spi.LifecycleListener -->
  <interface name="LifecycleListener"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="onStarted"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Notification that the Injector has been created.]]>
      </doc>
    </method>
    <method name="onStopped"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="error" type="java.lang.Throwable"/>
      <doc>
      <![CDATA[Notification that the Injector is shutting down]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Listener for Injector lifecycle events.  
 
 When writing a LifecycleListener that is managed by Guice, make sure to 
 inject all dependencies lazily using {@link Provider} injection.  Otherwise,
 these dependencies will be instantiated too early thereby bypassing lifecycle 
 features in LifecycleModule.]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.spi.LifecycleListener -->
  <!-- start interface com.netflix.governator.spi.ModuleListTransformer -->
  <interface name="ModuleListTransformer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="transform" return="java.util.List&lt;Module&gt;"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="modules" type="java.util.List&lt;Module&gt;"/>
      <doc>
      <![CDATA[Using the provided list of modules (and bindings) return a new augments list
 which may included additional bindings and modules.  
 
 @param modules
 @return New list of modules.  Can be the old list.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Module transformers are used to modify the final list of modules and return a 
 modified or augmented list of modules which may included additional or removed
 bindings.
 
 ModuleTransfomers can be used to do the following types of functionality,
 1.  Remove unwanted bindings
 2.  Auto add non-existent bindings 
 3.  Warn on dangerous bindings like toInstance() and static injection.]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.spi.ModuleListTransformer -->
  <!-- start interface com.netflix.governator.spi.ModuleTransformer -->
  <interface name="ModuleTransformer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="transform" return="Module"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="module" type="Module"/>
    </method>
    <doc>
    <![CDATA[Mapping function from one module to another.  A transformer could perform operations
 such as logging, removing dependencies or auto-generating bindings.]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.spi.ModuleTransformer -->
  <!-- start interface com.netflix.governator.spi.PropertySource -->
  <interface name="PropertySource"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of a property or null if not found
 
 @param key Name of property to fetch 
 @return Value or null if not found]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of a property or default if not found
 
 @param key Name of property to fetch 
 @param defaultValue
 @return Value or defaultValue if not found]]>
      </doc>
    </method>
    <method name="get" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Get a property value of a specific type
 
 @param key Name of property to fetch 
 @param type Type of value requested
 @return Value of the request type or null if not found]]>
      </doc>
    </method>
    <method name="get" return="T"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Get a property value of a specific type while returning a 
 default value if the property is not set.
 
 @param key Name of property to fetch 
 @param type Type of value requested
 @param defaultValue Default value to return if key not found
 @return Value or defaultValue if not found]]>
      </doc>
    </method>
    <method name="hasProperty" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Determine if the PropertySource contains the specified property key]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Very simple config interface to be used by Conditional to gain access
 to any type of configuration.
 
 @see PropertiesPropertySource]]>
    </doc>
  </interface>
  <!-- end interface com.netflix.governator.spi.PropertySource -->
</package>
<package name="com.netflix.governator.test">
  <!-- start class com.netflix.governator.test.TestLifecycleListener -->
  <class name="TestLifecycleListener" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="com.netflix.governator.spi.LifecycleListener"/>
    <constructor name="TestLifecycleListener"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="onStarted"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="onStopped"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
    </method>
    <method name="isStarted" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isStopped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getError" return="java.lang.Throwable"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="onReady"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="injector" type="Injector"/>
    </method>
  </class>
  <!-- end class com.netflix.governator.test.TestLifecycleListener -->
</package>
<package name="com.netflix.governator.visitors">
  <!-- start class com.netflix.governator.visitors.BindingTracingVisitor -->
  <class name="BindingTracingVisitor" extends="&lt;any&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="BindingTracingVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visit" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="&lt;any&gt;"/>
    </method>
    <doc>
    <![CDATA[Visitor for logging the entire binding information for each Element
 
 To use with {@link InjectorBuilder},
 
 <code>
 InjectorBuilder
      .withModules(new MyApplicationModule)
      .forEachElement(new BindingTracingVisitor())
      .createInjector();
 </code>]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.visitors.BindingTracingVisitor -->
  <!-- start class com.netflix.governator.visitors.IsNotStaticInjectionVisitor -->
  <class name="IsNotStaticInjectionVisitor" extends="&lt;any&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IsNotStaticInjectionVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="java.lang.Boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="Element"/>
    </method>
    <method name="visit" return="java.lang.Boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="StaticInjectionRequest"/>
    </method>
    <doc>
    <![CDATA[Predicate visitor that returns 'true' if an Element is a requestStaticInjection.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.visitors.IsNotStaticInjectionVisitor -->
  <!-- start class com.netflix.governator.visitors.IsStaticInjectionVisitor -->
  <class name="IsStaticInjectionVisitor" extends="&lt;any&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IsStaticInjectionVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="java.lang.Boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="Element"/>
    </method>
    <method name="visit" return="java.lang.Boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="StaticInjectionRequest"/>
    </method>
    <doc>
    <![CDATA[Predicate visitor that returns 'true' if an Element is a requestStaticInjection.]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.visitors.IsStaticInjectionVisitor -->
  <!-- start class com.netflix.governator.visitors.KeyTracingVisitor -->
  <class name="KeyTracingVisitor" extends="&lt;any&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyTracingVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visit" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="binding" type="&lt;any&gt;"/>
    </method>
    <doc>
    <![CDATA[Visitor for logging only the Key for each {@code Element} binding
 
 To use with {@link InjectorBuilder}
 
 <code>
 InjectorBuilder
      .fromModule(new MyApplicationModule)
      .forEachElement(new BindingTracingVisitor())
      .createInjector();
 </code>]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.visitors.KeyTracingVisitor -->
  <!-- start class com.netflix.governator.visitors.ModuleSourceTracingVisitor -->
  <class name="ModuleSourceTracingVisitor" extends="&lt;any&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ModuleSourceTracingVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visitOther" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="element" type="Element"/>
    </method>
    <doc>
    <![CDATA[Visitor for logging the 'path' through which each binding was created]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.visitors.ModuleSourceTracingVisitor -->
  <!-- start class com.netflix.governator.visitors.WarnOfStaticInjectionVisitor -->
  <class name="WarnOfStaticInjectionVisitor" extends="&lt;any&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="WarnOfStaticInjectionVisitor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="visit" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="element" type="StaticInjectionRequest"/>
    </method>
    <doc>
    <![CDATA[Visitor that log a warning for any use of requestStaticInjection]]>
    </doc>
  </class>
  <!-- end class com.netflix.governator.visitors.WarnOfStaticInjectionVisitor -->
</package>

</api>
